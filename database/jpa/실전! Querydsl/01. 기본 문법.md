## 01. 기본 문법

----

##### lombok 설명

1. @Setter: 실무에서 가급적 Setter는 사용하지 않기
2. @NoArgsConstructor AccessLevel.PROTECTED: 기본 생성자 막고 싶은데, JPA 스팩상 PROTECTED로 열어두어야 함
3. @ToString은 가급적 내부 필드만(연관관계 없는 필드만)
4. changeTeam() 으로 양방향 연관관계 한번에 처리(연관관계 편의 메소드)

----

##### JPQL vs Querydsl

- EntityManager 로 JPAQueryFactory 생성
- Querydsl은 JPQL 빌더
- JPQL: 문자(실행 시점 오류), Querydsl: 코드(컴파일 시점 오류)
- JPQL: 파라미터 바인딩 직접, Querydsl: 파라미터 바인딩 자동 처리
- JPAQueryFactory를 필드로 제공하면 동시성 문제는 어떻게 될까? 
  -> 동시성 문제는 JPAQueryFactory를 생성할 때 제공하는 EntityManager(em)에 달려있다. 
  스프링 프레임워크는 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도, 트랜잭션 마다 별도의 영속성 컨텍스트를 제공하기 때문에, 동시성 문제는 걱정하지 않아도 된다.

```java
@Test
public void startQuerydsl() {
			//member1을 찾아라.
			JPAQueryFactory queryFactory = new JPAQueryFactory(em); QMember m = new QMember("m");
      Member findMember = queryFactory
              .select(m)
							.from(m)
              .where(m.username.eq("member1"))//파라미터 바인딩 처리
              .fetchOne();
      assertThat(findMember.getUsername()).isEqualTo("member1");
}
 
@Test
public void startQuerydsl2() {
		//member1을 찾아라.
		QMember m = new QMember("m");
    Member findMember = queryFactory
            .select(m)
            .from(m)
            .where(m.username.eq("member1"))
            .fetchOne();
    assertThat(findMember.getUsername()).isEqualTo("member1");
}
 
```

----

##### 기본 Q-Type 활용

- Q클래스 인스턴스를 사용하는 2가지 방법

```java
QMember qMember = new QMember("m"); //별칭 직접 지정 
QMember qMember = QMember.member; //기본 인스턴스 사용

//기본 인스턴스를 static import와 함께 사용
import static study.querydsl.entity.QMember.*;

//다음 설정을 추가하면 실행되는 JPQL을 볼 수 있다.
spring.jpa.properties.hibernate.use_sql_comments: true
```

- 참고: 같은 테이블을 조인해야 하는 경우가 아니면 기본 인스턴스를 사용하자

----

##### JPQL이 제공하는 모든 검색 조건 제공

- 검색 조건은 .and(), or()를 메서드 체인으로 연결할 수 있다.

```java
member.username.eq("member1") // username = 'member1'
member.username.ne("member1") // username != 'member1'
member.username.eq("member1").not() // username != 'member1'

member.username.isNotNull() // 이름이 is not null

member.age.in(10, 20) // age in (10,20)
member.age.notIn(10, 20) // age not in (10, 20)
member.age.between(10,30) // between 10, 30

member.age.goe(30) // age >= 30
member.age.gt(30) // age > 30
member.age.loe(30) // age <= 30
member.age.lt(30) // age < 30

member.username.like("member%") // like 검색 
member.username.contains("member") // like ‘%member%’ 검색 
member.username.startsWith("member") // like ‘member%’ 검색
```

- **where() 에 파라미터로 검색조건을 추가하면 AND 조건이 추가됨**
- **이 경우 null 값은 무시** -> 메서드 추출을 활용해서 동적 쿼리를 깔끔하게 만들 수 있음

----

##### 결과 조회

- fetch(): 리스트 조회, 데이터 없으면 빈 리스트 반환
- fetchOne: 단 건 조회
  - 결과가 없으면: null
  - 결과가 둘 이상이면: com.querydsl.core.NonUniqueResultException
- fetchFirst(): limit(1).fetchOne()
- fetchResult(): 페이징 정보 포함, total count 쿼리 추가 실행
- fetchCount(): count 쿼리로 변경해서 count 수 조회

 

##### 정렬

- desc() , asc() : 일반 정렬
- nullsLast() , nullsFirst() : null 데이터 순서 부여

```java
List<Member> result = queryFactory
              .selectFrom(member)
              .where(member.age.eq(100))
              .orderBy(member.age.desc(), member.username.asc().nullsLast())
              .fetch();
```



##### 집합 & Group by

- groupBy , 그룹화된 결과를 제한하려면 having

```java
@Test
public void group() throws Exception {
		List<Tuple> result = queryFactory
                                .select(
                                team.name,
                                member.age.avg()
                                )
                                .from(member)
                                .join(member.team, team)
                                .groupBy(team.name)
                                .fetch();

    Tuple teamA = result.get(0);
    Tuple teamB = result.get(1);

    assertThat(teamA.get(team.name)).isEqualTo("teamA");
    assertThat(teamA.get(member.age.avg())).isEqualTo(15);

    assertThat(teamB.get(team.name)).isEqualTo("teamB");
    assertThat(teamB.get(member.age.avg())).isEqualTo(35);
}
```

----

##### 조인 - 기본 조인

- 조인의 기본 문법은 첫 번째 파라미터에 조인 대상을 지정하고, 두 번째 파라미터에 별칭으로 사용할 Q 타입을 지정하면 된다.
  1. join() , innerJoin() : 내부 조인(inner join)
  2. leftJoin() : left 외부 조인(left outer join)
  3. rightJoin() : rigth 외부 조인(rigth outer join)
- JPQL의 on과 성능 최적화를 위한 fetch 조인 제공

```java
List<Member> result = queryFactory
              .selectFrom(member)
              .join(member.team, team)
              .where(team.name.eq("teamA"))
              .fetch();
```



##### 세타 조인 - 연관 관계가 없는 필드로 조인

- from 절에 여러 엔티티를 선택해서 세타 조인
- 외부 조인 불가능 -> on 절을 사용하면 외부 조인 가능

```java
List<Member> result = queryFactory
              .select(member)
              .from(member, team)
              .where(member.username.eq(team.name))
              .fetch();
```



##### 조인 - on절

1. 조인 대상 필터링

   - ```java
     // JPQL: select m, t from Member m left join m.team t on t.name = 'teamA'
     List<Tuple> result = queryFactory
                     .select(member, team)
                     .from(member)
                     .leftJoin(member.team, team)
                     .on(team.name.eq("teamA"))
                     .fetch();
     ```

   - 참고: on 절을 활용해 조인 대상을 필터링 할 때, **외부조인이 아니라 내부조인(inner join)을 사용하면, where 절에서 필터링 하는 것과 기능이 동일하다.** 따라서 on 절을 활용한 조인 대상 필터링을 사용할 때, 내부조인 이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만 이 기능을 사용하자.

2. 연관관계 없는 엔티티 외부 조인

   - 하이버네이트 5.1부터 on 을 사용해서 서로 관계가 없는 필드로 외부 조인하는 기능이 추가되었다. 물론 내부 조인도 가능하다.

   - 주의! 문법을 잘 봐야 한다. **leftJoin()** 부분에 일반 조인과 다르게 엔티티 하나만 들어간다.

     - 일반 조인: leftjoin(member.team, team)
     - on 조인: from(member).leftjoin(team).on(xxx)

   - ```java
     List<Tuple> result = queryFactory
                     .select(member, team)
                     .from(member)
                     .leftJoin(team).on(member.username.eq(team.name))
                     .fetch();
     ```



##### 조인 - 페치 조인

- 페치 조인은 SQL에서 제공하는 기능은 아니다. SQL조인을 활용해서 연관된 엔티티를 SQL 한번에 조회하는 기능이다. 주로 성능 최적화에 사용하는 방법이다.

- ```java
  // join(), leftJoin() 등 조인 기능 뒤에 fetchJoin() 이라고 추가하면 된다.
  Member findMember = queryFactory
                  .selectFrom(member)
                  .join(member.team, team).fetchJoin()
                  .where(member.username.eq("member1"))
                  .fetchOne();
  ```

----

##### 서브 쿼리

- **com.querydsl.jpa.JPAExpressions** 사용

- **from절의 서브쿼리 한계**

  - JPA JPQL 서브쿼리의 한계점으로 from 절의 서브쿼리(인라인 뷰)는 지원하지 않는다. 
    당연히 Querydsl 도 지원하지 않는다. 하이버네이트 구현체를 사용하면 select 절의 서브쿼리는 지원한다. 
    Querydsl도 하이버네이트 구현체를 사용하면 select 절의 서브쿼리를 지원한다.

- **from절의 서브쿼리 해결방안**

  1. 서브쿼리를 join으로 변경한다. ( 가능한 상황도 있고, 불가능한 상황도 있다. )
  2. 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
  3. nativeSQL을 사용한다.

- ```java
  // 나이가 가장 많은 회원 조회
  // alias가 중복되므로 새로운 QMember를 선언 후 사용
  QMember memberSub = new QMember("memberSub");
  
  List<Member> result = queryFactory
                  .selectFrom(member)
                  .where(member.age.eq(
                            JPAExpressions.
                                  select(memberSub.age.max())
                                  .from(memberSub)
                  ))
                  .fetch();
  ```

- ```java
  // subquery in절
  QMember memberSub = new QMember("memberSub");
  
  List<Member> result = queryFactory
                    .selectFrom(member)
                    .where(member.age.in(
                              JPAExpressions.
                                    select(memberSub.age)
                                    .from(memberSub)
                                    .where(memberSub.age.gt(10))
                    ))
                    .fetch();
  ```



##### Case 문

- select, where, order by에서 사용 가능

- ```java
  // casebuilder 사용
  List<String> result = queryFactory
                  .select(
                          new CaseBuilder()
                                  .when(member.age.between(0, 20)).then("0~20살")
                                  .when(member.age.between(21, 40)).then("21~40살")
                                  .otherwise("기타")
                  )
                  .from(member)
                  .fetch();
  ```



##### 상수 더하기

- ```java
  // Expressions.constant(xxx) 사용
  List<Tuple> result = queryFactory
                  .select(
                          member.username,
                          Expressions.constant("A")
                  )
                  .from(member)
                  .fetch();
  ```

  

##### 문자 더하기

- **문자가 아닌 다른 타입들은 stringValue()로 문자로 변환할 수 있다.** 이 방법은 ENUM을 처리할 때도 자주 사용한다.

- ```java
  List<String> result = queryFactory
                  .select(member.username.concat("_").concat(member.age.stringValue()))
                  .from(member)
                  .where(member.username.eq("member1"))
                  .fetch();
  ```

  

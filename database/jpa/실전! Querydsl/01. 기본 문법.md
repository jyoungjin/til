## 01. 기본 문법

----

##### lombok 설명

1. @Setter: 실무에서 가급적 Setter는 사용하지 않기
2. @NoArgsConstructor AccessLevel.PROTECTED: 기본 생성자 막고 싶은데, JPA 스팩상 PROTECTED로 열어두어야 함
3. @ToString은 가급적 내부 필드만(연관관계 없는 필드만)
4. changeTeam() 으로 양방향 연관관계 한번에 처리(연관관계 편의 메소드)

----

##### JPQL vs Querydsl

- EntityManager 로 JPAQueryFactory 생성
- Querydsl은 JPQL 빌더
- JPQL: 문자(실행 시점 오류), Querydsl: 코드(컴파일 시점 오류)
- JPQL: 파라미터 바인딩 직접, Querydsl: 파라미터 바인딩 자동 처리
- JPAQueryFactory를 필드로 제공하면 동시성 문제는 어떻게 될까? 
  -> 동시성 문제는 JPAQueryFactory를 생성할 때 제공하는 EntityManager(em)에 달려있다. 
  스프링 프레임워크는 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도, 트랜잭션 마다 별도의 영속성 컨텍스트를 제공하기 때문에, 동시성 문제는 걱정하지 않아도 된다.

```java
@Test
public void startQuerydsl() {
			//member1을 찾아라.
			JPAQueryFactory queryFactory = new JPAQueryFactory(em); QMember m = new QMember("m");
      Member findMember = queryFactory
              .select(m)
							.from(m)
              .where(m.username.eq("member1"))//파라미터 바인딩 처리
              .fetchOne();
      assertThat(findMember.getUsername()).isEqualTo("member1");
}
 
@Test
public void startQuerydsl2() {
		//member1을 찾아라.
		QMember m = new QMember("m");
    Member findMember = queryFactory
            .select(m)
            .from(m)
            .where(m.username.eq("member1"))
            .fetchOne();
    assertThat(findMember.getUsername()).isEqualTo("member1");
}
 
```

----

##### 기본 Q-Type 활용

- Q클래스 인스턴스를 사용하는 2가지 방법

```java
QMember qMember = new QMember("m"); //별칭 직접 지정 
QMember qMember = QMember.member; //기본 인스턴스 사용

//기본 인스턴스를 static import와 함께 사용
import static study.querydsl.entity.QMember.*;

//다음 설정을 추가하면 실행되는 JPQL을 볼 수 있다.
spring.jpa.properties.hibernate.use_sql_comments: true
```

- 참고: 같은 테이블을 조인해야 하는 경우가 아니면 기본 인스턴스를 사용하자

----

##### JPQL이 제공하는 모든 검색 조건 제공

- 검색 조건은 .and(), or()를 메서드 체인으로 연결할 수 있다.

```java
member.username.eq("member1") // username = 'member1'
member.username.ne("member1") // username != 'member1'
member.username.eq("member1").not() // username != 'member1'

member.username.isNotNull() // 이름이 is not null

member.age.in(10, 20) // age in (10,20)
member.age.notIn(10, 20) // age not in (10, 20)
member.age.between(10,30) // between 10, 30

member.age.goe(30) // age >= 30
member.age.gt(30) // age > 30
member.age.loe(30) // age <= 30
member.age.lt(30) // age < 30

member.username.like("member%") // like 검색 
member.username.contains("member") // like ‘%member%’ 검색 
member.username.startsWith("member") // like ‘member%’ 검색
```

- **where() 에 파라미터로 검색조건을 추가하면 AND 조건이 추가됨**
- **이 경우 null 값은 무시** -> 메서드 추출을 활용해서 동적 쿼리를 깔끔하게 만들 수 있음

----

##### 결과 조회

- fetch(): 리스트 조회, 데이터 없으면 빈 리스트 반환
- fetchOne: 단 건 조회
  - 결과가 없으면: null
  - 결과가 둘 이상이면: com.querydsl.core.NonUniqueResultException
- fetchFirst(): limit(1).fetchOne()
- fetchResult(): 페이징 정보 포함, total count 쿼리 추가 실행
- fetchCount(): count 쿼리로 변경해서 count 수 조회

##### 

##### 정렬

- desc() , asc() : 일반 정렬
- nullsLast() , nullsFirst() : null 데이터 순서 부여

```java
List<Member> result = queryFactory
              .selectFrom(member)
              .where(member.age.eq(100))
              .orderBy(member.age.desc(), member.username.asc().nullsLast())
              .fetch();
```


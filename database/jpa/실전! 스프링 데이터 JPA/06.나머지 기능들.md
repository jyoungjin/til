## 06. 나머지 기능들

----

##### Specifications ( 명세 )

- 책 도메인 주도 설계(Domain Driven Design)는 SPECIFICATION(명세)라는 개념을 소개
- 스프링 데이터 JPA는 JPA Criteria를 활용해서 이 개념을 사용할 수 있도록 지원
- 술어(predicate)
  - 참 또는 거짓으로 평가
  - AND OR 같은 연산자로 조합해서 다양한 검색조건을 쉽게 생성(컴포지트 패턴)
  - 예) 검색 조건 하나하나
  - 스프링 데이터 JPA는 org.springframework.data.jpa.domain.Specification 클래스로 정의
- **참고: 실무에서는 JPA Criteria를 거의 안 쓴다! 대신에 QueryDSL을 사용하자.**



##### Query By Example

- 장점

  - 동적 쿼리를 편리하게 처리
  - 도메인 객체를 그대로 사용
  - 데이터 저장소를 RDB에서 NOSQL로 변경해도 코드 변경이 없게 추상화 되어 있음
  - 스프링 데이터 JPA 인터페이스에 이미 포함

- 단점

  - 조인은 가능하지만 내부 조인만 가능함, 외부 조인 불가

  - 다음과 같은 중첩 제약조건 안됨

    - ```sql
      firstname = ?0 or (firstname = ?1 and lastname = ?2)
      ```

  - 매칭 조건이 단순함

    - 문자는 starts/contains/ends/regex
    - 다른 속성은 정확한 매칭( = )만 지원

- **참고: 실무에서 사용하기에는 매칭 조건이 너무 단순하고, LEFT 조인이 안 되기 때문에 QueryDSL을 사용하자.**

----

##### Projections

- 엔티티 대신에 DTO를 편리하게 조회할 때 사용
- 예) 전체 엔티티가 아니라 만약 회원 이름만 딱 조회하고 싶으면?

1. **인터페이스 기반 Closed Projections**

   - 프로퍼티 형식(getter)의 인터페이스를 제공하면, 구현체는 스프링 데이터 JPA가 제공

   - ```java
     public interface UsernameOnly {    
     		String getUsername();
     }
     ```

2. **인터페이스 기반 Open Projections**

   - 다음과 같이 스프링의 SpEL 문법도 지원

   - ```java
     public interface UsernameOnly {
     		@Value("#{target.username + ' ' + target.age + ' ' + target.team.name}")
     		String getUsername();
     }
     ```

   - 단! 이렇게 SpEL문법을 사용하면, DB에서 엔티티 필드를 다 조회해온 다음에 계산한다.
     따라서 JPQL SELECT절 최적화가 안된다.

3. **클래스 기반 Projection**

   - 다음과 같이 인터페이스가 아닌 구체적인 DTO 형식도 가능

   - 생성자의 파라미터 이름으로 매칭

   - ```java
     public class UsernameOnlyDto {
           private final String username;
           public UsernameOnlyDto(String username) {
               this.username = username;
     			}
           public String getUsername() {
               return username;
     			} 
     }
     ```

4. **동적 Projections**

   - 다음과 같이 Generic type을 주면, 동적으로 프로젝션 데이터 번경 가능

   - ```java
     <T> List<T> findProjectionsByUsername(String username, Class<T> type);
     
     //사용코드
     List<UsernameOnly> result = memberRepository.findProjectionsByUsername("m1", UsernameOnly.class);
     ```

5. **중첩 구조 처리**

   - ```java
     public interface NestedClosedProjections {
     
         String getUsername();
         TeamInfo getTeam();
     
         interface TeamInfo {
             String getName();
         }
     }
     ```

   - 프로젝션 대상이 root 엔티티면, JPQL SELECT 절 최적화 가능

   - 프로젝션 대상이 ROOT가 아니면

     - LEFT OUTER JOIN 처리
     - 모든 필드를 SELECT해서 엔티티로 조회한 다음에 계산



- 정리
  - 프로젝션 대상이 root 엔티티를 넘어가면 JPQL SELECT 최적화가 안된다!
  - 실무에서 복잡한 쿼리를 해결하기에는 한계가 있다.
  - 실무에서는 단순할 때만 사용하고, 조금만 복잡해지면 QueryDSL을 사용하자.

----

##### 네이티브 쿼리

- 가급적 네이티브 쿼리는 사용하지 않는게 좋음, 정말 어쩔 수 없을 때 사용
- 최근에 나온 궁극의 방법 스프링 데이터 Projections 활용

JPA 네이티브 SQL 지원

- ```java
  @Query(value = "select * from member where username = ?", nativeQuery = true)
  Member findByNativeQuery(String username);
  ```

스프링 데이터 JPA 기반 

- 페이징 지원
- 반환 타입
  - Object[]
  - Tuple
  - DTO ( 스프링 데이터 인터페이스 Projections 지원 )
- 제약
  - Sort 파라미터를 통한 정렬이 정상 동작하지 않을 수 있음(믿지 말고 직접 처리)
  - JPQL처럼 애플리케이션 로딩 시점에 문법 확인 불가
  - 동적 쿼리 불가
- JPQL은 위치 기반 파리미터를 1부터 시작하지만 네이티브 SQL은 0부터 시작
- 네이티브 SQL을 엔티티가 아닌 DTO로 변환은 하려면
  - DTO 대신 JPA TUPLE 조회
  - DTO 대신 MAP 조회
  - @SqlResultSetMapping 복잡
  - Hibernate ResultTransformer를 사용해야함 복잡
  - 네이티브 SQL을 DTO로 조회할 때는 JdbcTemplate or myBatis 권장

##### **Projections** **활용**

- 예) 스프링 데이터 JPA 네이티브 쿼리 + 인터페이스 기반 Projections 활용

- ```java
  @Query(value = "SELECT m.member_id as id, m.username, t.name as teamName " +
                "FROM member m left join team t",
                countQuery = "SELECT count(*) from member",
                nativeQuery = true)
  Page<MemberProjection> findByNativeProjection(Pageable pageable);	
  ```

  

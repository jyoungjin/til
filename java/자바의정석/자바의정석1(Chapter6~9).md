# Java의 정석 1 (Chapter 6~9)

### 2021/07/03~2021/07/06

----

## Chapter 6. 객체지향 프로그래밍 1

#### 객체지향 이론: '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'

- 장점: 코드의 재사용성이 높고 유지보수가 용이하다.

#### 객체의 구성요소 (속성과 기능)

1. 속성: 멤버변수, 특성, 필드, 상태
2. 기능: 메서드, 함수, 행위

> 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.

#### 변수 종류

1. 인스턴스 변수

   - 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.

   - 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다. 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.

2. 클래스 변수

   - 클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static을 붙이기만 하면 된다.
   - 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.
   - 클래스 변수를 사용할 때는 'className.classVariable'의 형태로 사용하는 것이 좋다. (인스턴스 변수로 오해하는 것을 방지하기 위함.)

3. 지역 변수

   - 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

![img](https://t1.daumcdn.net/cfile/tistory/21226F42578D2F8137)

----

#### JVM의 메모리 구조

> 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

1. 메서드 영역 (method area)
   - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스 변수도 이 영역에 함께 생성된다.
2. 힙 (heap)
   - 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스 변수들이 생성되는 공간이다.
3. 호출스택 (call stack or execution stack)
   - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.

#### 호출 스택의 특징

* 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
* 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
* 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
* 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

#### 기본형 매개변수 vs 참조형 매개변수

1. 기본형 매개변수: Read Only
2. 참조형 매개변수: Read and Write'

#### 클래스 메서드와 인스턴스 메서드

- 클래스 메서드: 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드

- 인스턴스 메서드: 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드

1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

----

#### 오버로딩

- 오버로딩의 조건
  1. 메서드 이름이 같아야 한다.
  2. 매개변수의 개수 또는 타입이 달라야 한다.

- JDK1.5부터 가변인자 지정 가능 

#### 생성자

1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.
3. 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

#### 생성자에서 다른 생성자 호출하기

1. 생성자의 이름으로 클래스이름 대신 this를 사용한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

> this: 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.
>
> this(), this(매개변수): 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.

### 변수의 초기화

> 멤버 변수(클래스 변수, 인스턴스 변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.

- 멤버변수의 초기화 방법

  1. 명시적 초기화
  2. 생성자
  3. 초기화 블럭
     1. 인스턴스 초기화 블럭
     2. 클래스 초기화 블럭

  ```java
  class BlockTest {
  	static {
  		// 클래스 초기화 블럭
  	}
  	
  	{
  		// 인스턴스 초기화 블럭
  	}
  	
  	public BlockTest() {
  		// 생성자
  	}
  	
  	public static void main(String args[]) {
  		// main 메서드
  	}
  }
  ```

- 멤버변수의 초기화 시기와 순서

  1. 클래스 변수
     - 시점: 클래스가 처음 로딩될 때 단 한번 초기화 된다.
     - 순서: 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
  2. 인스턴스 변수
     - 시점: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.
     - 순서: 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

----

## Chapter 7. 객체지향 프로그래밍 2

#### 상속

> 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- Java는 단일 상속만 지원한다.
- 모든 상속계층도의 최상위에는 Object Class가 위치한다.
  - 따라서, toString(), equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용가능하다.

#### 상속관계 vs 포함관계

> 상속관계: '~은 ~이다.(is-a)'
>
> 포함관계: '~은 ~을 가지고 있다.(has-a)'

#### 오버라이딩

> 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

- 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와

  1. 자손 클래스와 조상클래스에서 이름이 같아야 한다.

  2. 자손 클래스와 조상클래스에서 매개변수가 같아야 한다.

  3. 자손 클래스와 조상클래스에서 반환타입이 같아야 한다.

- 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때

  1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
  2. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
  3. 인스턴스 메서드를 static 메서든 또는 그 반대로 변경할 수 없다.

#### super 참조변수

````java
class SuperTest {
	public static void main(String args[]) {
		Child c = new Child();
		c.method();
	}
}

class Parent {
	int x = 10;
}

class Child extends Parent {
	int x = 20;
	
	void method() {
		System.out.println("x=" + x);                // 20
    System.out.println("this.x=" + this.x);      // 20
    System.out.println("super.x=" + super.x);    // 10
	}
}
````

----

#### 패키지 (package)

> 클래스 또는 인터페이스의 묶음

- 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
  - 선언: package 패키지명 
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉터리이다.

#### import vs import static

- import static으로 지정하면 클래스 이름을 생략 할 수 있다.

----

#### 제어자

>클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

1. 접근 제어자: public, protected, default, private
2. 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp

final: final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.

abstract 클래스: 클래스 내에 추상 메서드가 선언되어 있음을 의미

abstract 메서드: 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 의미


## 06. 스프링 MVC - 기본 기능

----

##### 요청 매핑

- @Controller는 반환 값이 String 이면 뷰 이름으로 인식된다. 그래서 **뷰를 찾고 뷰가 랜더링** 된다.

- @RestController는 반환 값으로 뷰를 찾는 것이 아니라, **HTTP** **메시지 바디에 바로 입력**한다.

- @RequestMapping에 method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다.

- ```java
  // 경로와 변수명이 같으면 생략 가능
  @PathVariable("userId") String userId -> @PathVariable String userId
  ```

- Content-Type 헤더 기반 추가 매핑 

  - ```java
    /**
    * Content-Type 헤더 기반 추가 매핑 Media Type * consumes="application/json"
    
    * consumes="!application/json"
    * consumes="application/*"
    * consumes="*\/*"
    * MediaType.APPLICATION_JSON_VALUE
    */
    @PostMapping(value = "/mapping-consume", consumes = "application/json")
    public String mappingConsumes() {
            log.info("mappingConsumes");
            return "ok";
    }
    ```

- Accept 헤더 기반

  - ```java
    /**
    * Accept 헤더 기반 Media Type * produces = "text/html"
    * produces = "!text/html" * produces = "text/*"
    * produces = "*\/*"
    */
    @PostMapping(value = "/mapping-produce", produces = "text/html")
    public String mappingProduces() {
            log.info("mappingProduces");
            return "ok";
    }
    ```



##### 요청 매핑 - API 예시

- 회원 목록 조회: GET - /users
- 회원 등록: POST - /users
- 회원 조회: GET - /users/{userId}
- 회원 수정; PATCH - /users/{userId}
- 회원 삭제: DELETE - /users/{userId}



##### RequestHeaderController

```java
// MultiValueMap - MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.
// HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.
public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String, String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCookie", required = false) String cookie
                          ) {

        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);
        return "ok";
}
```



##### HTTP 요청 데이터 조회

1. **GET -** **쿼리 파라미터**
   - /url**?username=hello&age=20**
   - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
   - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식
2. **POST - HTML Form**
   - content-type: application/x-www-form-urlencoded
   - 메시지 바디에 쿼리 파리미터 형식으로 전달 username=hello&age=20
   - 예) 회원 가입, 상품 주문, HTML Form 사용
3. **HTTP message body**에 데이터를 직접 담아서 요청
   - HTTP API에서 주로 사용, JSON, XML, TEXT
   - 데이터 형식은 주로 JSON 사용
   - POST, PUT, PATCH



##### HTTP 요청 메시지 - 단순 텍스트

- **HTTP message body**에 데이터를 직접 담아서 요청

- **HttpEntity**: HTTP header, body 정보를 편리하게 조회

  - 메시지 바디 정보를 직접 조회
  - 요청 파라미터를 조회하는 기능과 관계 없음 @RequestParam X, @ModelAttribute X

- **HttpEntity**는 응답에도 사용 가능

  - 메시지 바디 정보 직접 반환
  - 헤더 정보 포함 가능
  - view 조회X

- HttpEntity 를 상속받은 다음 객체들도 같은 기능을 제공한다.

  - **RequestEntity**

    - HttpMethod, url 정보가 추가, 요청에서 사용

  - **ResponseEntity**

    - HTTP 상태 코드 설정 가능, 응답에서 사용

    - ```java
       return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED)
      ```



##### **@RequestBody**

- @RequestBody 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다. 
  참고로 헤더 정보가 필요하다면 HttpEntity 를 사용하거나 @RequestHeader 를 사용하면 된다.
  이렇게 **메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 @RequestParam , @ModelAttribute 와는 전혀 관계가 없다.**

```java
@ResponseBody
@PostMapping("/request-body-string-v4")
public String requestBodyStringV4(@RequestBody String messageBody) {
        log.info("messageBody={}", messageBody);
        return "ok";
}
```

##### **@ResponseBody**

- @ResponseBody 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다. 물론 이 경우에도 view를 사용하지 않는다.



##### 요청 파라미터 vs HTTP 메시지 바디

- 요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttribute
- HTTP 메시지 바디를 직접 조회하는 기능: @RequestBody



##### @RequestBody는 생략 불가능

- 스프링은 @ModelAttribute , @RequestParam 과 같은 해당 애노테이션을 생략시 다음과 같은 규칙을 적용한다.

  - String , int , Integer 같은 단순 타입 = @RequestParam
  - 나머지 = @ModelAttribute (argument resolver 로 지정해둔 타입 외)

- >HTTP 요청시에 content-type이 application/json인지 꼭! 확인해야 한다. 
  >그래야 JSON을 처리할 수 있는 HTTP 메시지 컨버터가 실행된다.

----

##### HTTP 응답 - 정적 리소스, 뷰 템플릿

- 정적 리소스
  - 예) 웹 브라우저에 정적인 HTML, css, js를 제공할 때는, 정적 리소스를 사용한다.
  - 스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공한다.
    - /static , /public , /resources , /META-INF/resources
    - src/main/resources 는 리소스를 보관하는 곳이고, 또 클래스패스의 시작 경로이다.
- 뷰 템플릿
  - 예) 웹 브라우저에 동적인 HTML을 제공할 떄는 뷰 템플릿을 사용한다.
  - 뷰 템플릿 경로: src/main/resources/templates
- HTTP 메시지 사용
  - 예) HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, 
    HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.

----

##### HTTP 메시지 컨버터

- HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.
- @ResponseBody 를 사용
  - HTTP의 BODY에 문자 내용을 직접 반환
  - viewResolver 대신에 HttpMessageConverter 가 동작
  - 기본 문자처리: StringHttpMessageConverter
  - 기본 객체처리: MappingJackson2HttpMessageConverter
  - byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음
- **스프링 MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.**
  - HTTP 요청: @RequestBody , HttpEntity(RequestEntity)
    - canRead() , canWrite() : 메시지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크
  - HTTP 응답: @ResponseBody , HttpEntity(ResponseEntity)
    - read() , write() : 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능



##### **ArgumentResolver**

- 생각해보면, 애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있었다.
  HttpServletRequest , Model 은 물론이고, @RequestParam , @ModelAttribute 같은 애노테이션 
  그리고 @RequestBody , HttpEntity 같은 HTTP 메시지를 처리하는 부분까지 매우 큰 유연함을 보여주었다.
  이렇게 파라미터를 유연하게 처리할 수 있는 이유가 바로 ArgumentResolver 덕분이다.

- **동작 방식**
  - ArgumentResolver 의 supportsParameter() 를 호출해서 해당 파라미터를 지원하는지 체크하고, 
    지원하면 resolveArgument() 를 호출해서 실제 객체를 생성한다. 그리고 이렇게 생성된 객체가 컨트롤러 호출시 넘어가는 것이다.

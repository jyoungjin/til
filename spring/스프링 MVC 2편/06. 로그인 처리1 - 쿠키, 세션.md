## 06. 로그인 처리1 - 쿠키, 세션

----

##### 로그인 처리하기 - 쿠키 사용

- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지



##### 쿠키와 보안 문제

- 쿠키 값은 임의로 변경할 수 있다.
  - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
  - 실제 웹브라우저 개발자모드 Application Cookie 변경으로 확인
  - Cookie: memberId=1 Cookie: memberId=2 (다른 사용자의 이름이 보임)
- 쿠키에 보관된 정보는 훔쳐갈 수 있다.
  - 만약 쿠키에 개인정보나, 신용카드 정보가 있다면?
  - 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.
  - 쿠키의 정보가 나의 로컬 PC에서 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.
- 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
  - 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.

##### 대안

- 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 
  그리고 서버에서 토큰을 관리한다.
- 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
- 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지한다. 
  또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.



##### 로그인 처리하기 - 세션 동작 방식

- 앞서 쿠키에 중요한 정보를 보관하는 방법은 여러가지 보안 이슈가 있었다. 
  이 문제를 해결하려면 결국 중요한 정보를 모두 서버에 저장해야 한다. 
  그리고 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.
- 이렇게 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.

##### 세션 동작 방식

- 사용자가 loginId , password 정보를 전달하면 서버에서 해당 사용자가 맞는지 확인한다.
- 세션 ID를 생성하는데, 추정 불가능해야 한다.
- 생성된 세션 ID와 세션에 보관할 값( memberA )을 서버의 세션 저장소에 보관한다.
- **클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다**.
  - 서버는 클라이언트에 mySessionId 라는 이름으로 세션ID만 쿠키에 담아서 전달한다.
  - 클라이언트는 쿠키 저장소에 mySessionId 쿠키를 보관한다.
- **요점**
  - 여기서 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것이다.
  - 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.
- 클라이언트의 세션id 쿠키 전달
  - 클라이언트는 요청시 항상 mySessionId 쿠키를 전달한다.
  - 서버에서는 클라이언트가 전달한 mySessionId 쿠키 정보로 세션 저장소를 조회해서 로그인시 보관한 세션 정보를 사용한다.
- **정리**
  - 쿠키 값을 변조 가능, 예상 불가능한 복잡한 세션Id를 사용한다.
  - 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다. -> 세션Id가 털려도 여기에는 중요한 정보가 없다.
  - 쿠키 탈취 후 사용 -> 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 세션의 만료시간을 짧게(예: 30분) 유지한다. 
    또는 해킹이 의심되는 경우 서버에서 해당 세션을 강제로 제거하면 된다.



##### 로그인 처리하기 - 서블릿 HTTP 세션1

- HttpSession 소개
  - 서블릿이 제공하는 HttpSession 도 결국 우리가 직접 만든 SessionManager 와 같은 방식으로 동작한다. 
    서블릿을 통해 HttpSession 을 생성하면 다음과 같은 쿠키를 생성한다. 쿠키 이름이 JSESSIONID 이고, 값은 추정 불가능한 랜덤 값이다.
  - Cookie: JSESSIONID=5B78E23B513F50164D6FDD8C97B0AD05
- **세션 생성과 조회**
  - 세션을 생성하려면 request.getSession(true) 를 사용하면 된다.
    - request.getSession(true)
      - 세션이 있으면 기존 세션을 반환한다.
      - 세션이 없으면 새로운 세션을 생성해서 반환한다.
    - request.getSession(false)
      - 세션이 있으면 기존 세션을 반환한다.
      - 세션이 없으면 새로운 세션을 생성하지 않는다. null 을 반환한다.

##### 로그인 처리하기 - 서블릿 HTTP 세션2

- 스프링은 세션을 더 편리하게 사용할 수 있도록 **@SessionAttribute** 을 지원한다.

- 이미 로그인 된 사용자를 찾을 때는 다음과 같이 사용하면 된다. 참고로 이 기능은 세션을 생성하지 않는다.

  - ```java
    @SessionAttribute(name = "loginMember", required = false) Member loginMember
    ```

- TrackingModes

  - 로그인을 처음 시도하면 URL이 다음과 같이 jsessionid 를 포함하고 있는 것을 확인할 수 있다.

  - 이것은 웹 브라우저가 쿠키를 지원하지 않을 때 쿠키 대신 URL을 통해서 세션을 유지하는 방법이다.

  - URL 전달 방식을 끄고 항상 쿠키를 통해서만 세션을 유지하고 싶으면 다음 옵션을 넣어주면 된다.

    - ```properties
      server.servlet.session.tracking-modes=cookie
      ```



##### 세션 정보와 타임아웃 설정

- sessionId : 세션Id, JSESSIONID 의 값이다. 예) 34B14F008AA3527C9F8ED620EFD7A4E1
- maxInactiveInterval : 세션의 유효 시간, 예) 1800초, (30분)
- creationTime : 세션 생성일시
- lastAccessedTime :세션과 연결된 사용자가 최근에 서버에 접근한 시간,클라이언트에서 서버로 sessionId ( JSESSIONID )를 요청한 경우에 갱신된다.
- isNew : 새로 생성된 세션인지, 아니면 이미 과거에 만들어졌고, 클라이언트에서 서버로 sessionId ( JSESSIONID )를 요청해서 조회된 세션인지 여부



##### 세션 타임아웃 설정

- 세션은 사용자가 로그아웃을 직접 호출해서 session.invalidate() 가 호출 되는 경우에 삭제된다.
  그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료한다.
  문제는 **HTTP가 비 연결성(ConnectionLess)**이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를 인식할 수 없다. 
  따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기가 어렵다.

- **세션의 종료 시점**

  - **사용자가 서버에 최근에 요청한 시간을 기준으로 30분 정도를 유지해주는 것**
  - HttpSession 은 이 방식을 사용한다.

- **세션 타임아웃 설정**

  - ```properties
    # 60초, 기본은 1800(30분)
    # 글로벌 설정은 분 단위로 설정해야 한다. 60(1분), 120(2분), ...
    server.servlet.session.timeout=60
    ```

- 특정 세션 단위로 시간 설정

  - ```java
    session.setMaxInactiveInterval(1800); // 1800초
    ```

- LastAccessedTime 이후로 timeout 시간이 지나면, WAS가 내부에서 해당 세션을 제거한다.

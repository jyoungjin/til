## 07. 로그인 처리2 - 필터, 인터셉터

----

##### 서블릿 필터

- 공통 관심 사항

  - 문제는 로그인 하지 않은 사용자도 다음 URL을 직접 호출하면 상품 관리 화면에 들어갈 수 있다는 점이다.
  - 애플리케이션 여러 로직에서 공통으로 관심이 있는 있는 것을 **공통 관심사(cross-cutting concern)**라고 한다. 
    여기서는 등록, 수정, 삭제, 조회 등등 여러 로직에서 공통으로 인증에 대해서 관심을 가지고 있다.
  - 이러한 공통 관심사는 스프링의 AOP로도 해결할 수 있지만, 
    웹과 관련된 공통 관심사는 **서블릿 필터 또는 스프링 인터셉터**를 사용하는 것이 좋다.
    웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데, 
    서블릿 필터나 스프링 인터셉터는 **HttpServletRequest** 를 제공한다.

- **서블릿 필터 흐름**

  - ```markdown
    ##### 필터 흐름
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러
    
    ##### 필터 제한
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 // 로그인 사용자
    HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출 X) // 비 로그인 사용자
    
    ##### 필터 체인
    HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러
    ```

  - 필터를 적용하면 필터가 호출 된 다음에 서블릿이 호출된다. 
    그래서 모든 고객의 요청 로그를 남기는 요구사항이 있다면 필터를 사용하면 된다. 
    참고로 필터는 특정 URL 패턴에 적용할 수 있다. /* 이라고 하면 모든 요청에 필터가 적용된다.
    참고로 스프링을 사용하는 경우 여기서 말하는 서블릿은 스프링의 디스패처 서블릿으로 생각하면 된다.



##### 필터 인터페이스

```java
// 필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고, 관리한다.
public interface Filter {
  
  		// 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
      public default void init(FilterConfig filterConfig) throws ServletException{}
      
  		// 고객의 요청이 올 때 마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다.
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
      throws IOException, ServletException;
              
  		// 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.
      public default void destroy() {}
}
```

```java
// WebConfig - 필터 설정
@Configuration
public class WebConfig {
 
      @Bean
  		public FilterRegistrationBean logFilter() {
        
            FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();
        		// setFilter(new LogFilter()) : 등록할 필터를 지정한다.
            filterRegistrationBean.setFilter(new LogFilter());
        		// setOrder(1) : 필터는 체인으로 동작한다. 따라서 순서가 필요하다. 낮을 수록 먼저 동작한다.
            filterRegistrationBean.setOrder(1);
        		// addUrlPatterns("/*") : 필터를 적용할 URL 패턴을 지정한다. 한번에 여러 패턴을 지정할 수 있다.
            filterRegistrationBean.addUrlPatterns("/*");

        		return filterRegistrationBean;
			} 
  
      @Bean
      public FilterRegistrationBean loginCheckFilter() {
        
            FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();
            filterRegistrationBean.setFilter(new LoginCheckFilter());
            filterRegistrationBean.setOrder(2);
            filterRegistrationBean.addUrlPatterns("/*");

            return filterRegistrationBean;
      }
}
```

>@ServletComponentScan @WebFilter(filterName = "logFilter", urlPatterns = "/*") 로 필터 등록이 가능하지만 필터 순서 조절이 안된다. 따라서 **FilterRegistrationBean** 을 사용하자.
>실무에서 HTTP 요청시 같은 요청의 로그에 모두 같은 식별자를 자동으로 남기는 방법은 logback mdc로 검색해보자.

----

##### 스프링 인터센터

- 서블릿 필터가 서블릿이 제공하는 기술이라면, **스프링 인터셉터는 스프링 MVC가 제공하는 기술**이다. 
  둘다 웹과 관련된 공통 관심 사항을 처리하지만, 적용되는 순서와 범위, 그리고 사용방법이 다르다.

- **스프링 인터셉터 흐름**

  - ```markdown
    ##### 스프링 인터셉터 흐름
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터센터 -> 컨트롤러
    
    ##### 스프링 인터셉터 제한
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터센터 -> 컨트롤러 // 로그인 사용자
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이라 판단, 서블릿 호출 X) // 비 로그인 사용자
    
    ##### 스프링 인터셉터 체인
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러
    ```

  - 스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출 된다.

  - 스프링 인터셉터는 스프링 MVC가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다. 
    스프링 MVC의 시작점이 디스패처 서블릿이라고 생각해보면 이해가 될 것이다.

  - 스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할 수 있다.

  - 스프링 인터셉터는 서블릿 필터보다 편리하고, 더 정교하고 다양한 기능을 지원한다.



##### 스프링 인터셉터 인터페이스

```java
public interface HandlerInterceptor {

  	// 컨트롤러 호출 전
    default boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                              Object handler) throws Exception {}
                   
  	// 컨트롤러 호출 후
    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, 			                  														@Nullable ModelAndView modelAndView) throws Exception {}
    
  	// 요청 완료 이후
    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, 																	 @Nullable Exception ex) throws Exception {}
    
 }
```

```java
// 스프링 인터셉터 등록
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LogInterceptor())
                .order(1)
                .addPathPatterns("/**")
                .excludePathPatterns("/css/**", "/*.ico", "/error");
      
      	registry.addInterceptor(new LoginCheckInterceptor())
                .order(2)
                .addPathPatterns("/**")
                .excludePathPatterns("/", "members/add", "/login", "/logout",
                        "/css/**", "/*.ico", "/error");
    }
}
```



- 서블릿 필터의 경우 단순하게 doFilter() 하나만 제공된다. 
  인터셉터는 컨트롤러 호출 전( preHandle ), 호출 후( postHandle ), 요청 완료 이후( afterCompletion )와 같이 단계적으로 잘 세분화 되어 있다.
- 서블릿 필터의 경우 단순히 request , response 만 제공했지만, 인터셉터는 **어떤 컨트롤러( handler )가 호출되는지 호출 정보**도 받을 수 있다. 
  그리고 어떤 **modelAndView 가 반환되는지 응답 정보**도 받을 수 있다.



##### 스프링 인터셉터 정상 흐름

- **preHandle** : 컨트롤러 호출 전에 호출된다. (더 정확히는 핸들러 어댑터 호출 전에 호출된다.)
  - preHandle 의 응답값이 true 이면 다음으로 진행하고, false 이면 더는 진행하지 않는다. false인 경우 나머지 인터셉터는 물론이고, 
    핸들러 어댑터도 호출되지 않는다. 그림에서 1번에서 끝이 나버린다.
- **postHandle** : 컨트롤러 호출 후에 호출된다. (더 정확히는 핸들러 어댑터 호출 후에 호출된다.)
- **afterCompletion** : 뷰가 렌더링 된 이후에 호출된다.



##### 스프링 인터셉터 예외 상황

- **preHandle** : 컨트롤러 호출 전에 호출된다.
- **postHandle** : 컨트롤러에서 예외가 발생하면 postHandle 은 호출되지 않는다.
- **afterCompletion** : afterCompletion 은 항상 호출된다. 이 경우 예외( ex )를 파라미터로 받아서 어떤 예외가 발생했는지 로그로 출력할 수 있다.
  - 예외가 발생하면 postHandle() 는 호출되지 않으므로 예외와 무관하게 공통 처리를 하려면 afterCompletion() 을 사용해야 한다.
  - 예외가 발생하면 afterCompletion() 에 예외 정보( ex )를 포함해서 호출된다.



##### PathPattern 공식 문서

- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.html

```markdown
? 한 문자 일치
* 경로(/) 안에서 0개 이상의 문자 일치
** 경로 끝까지 0개 이상의 경로(/) 일치
{spring} 경로(/)와 일치하고 spring이라는 변수로 캡처
{spring:[a-z]+} matches the regexp [a-z]+ as a path variable named "spring" {spring:[a-z]+} regexp [a-z]+ 와 일치하고, "spring" 경로 변수로 캡처
{*spring} 경로가 끝날 때 까지 0개 이상의 경로(/)와 일치하고 spring이라는 변수로 캡처

/pages/t?st.html — matches /pages/test.html, /pages/tXst.html but not /pages/toast.html
/resources/*.png — matches all .png files in the resources directory
/resources/** — matches all files underneath the /resources/ path, including / resources/image.png and /resources/css/spring.css
/resources/{*path} — matches all files underneath the /resources/ path and captures their relative path in a variable named "path"; /resources/image.png will match with "path" → "/image.png", and /resources/css/spring.css will match with "path" → "/css/spring.css" /resources/{filename:\\w+}.dat will match /resources/spring.dat and assign the value "spring" to the filename variable
```

----

##### ArgumentResolver 활용

```java
@GetMapping("/")
public String homeLoginV3ArgumentResolver(@Login Member loginMember, Model model) {
			//세션에 회원 데이터가 없으면 home 
			if (loginMember == null) {
          return "home";
      }
      
			//세션이 유지되면 로그인으로 이동 
			model.addAttribute("member", loginMember); return "loginHome";
}
```

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target(ElementType.PARAMETER)  // 파라미터에만 사용
@Retention(RetentionPolicy.RUNTIME)  // 리플렉션 등을 활용할 수 있도록 런타임까지 애노테이션 정보가 남아있음
public @interface Login {
}
```

```java
@Slf4j
public class LoginMemberArgumentResolver implements HandlerMethodArgumentResolver {
      
      @Override
			public boolean supportsParameter(MethodParameter parameter) { 
					
					log.info("supportsParameter 실행");
          boolean hasLoginAnnotation = parameter.hasParameterAnnotation(Login.class);
          boolean hasMemberType = Member.class.isAssignableFrom(parameter.getParameterType());
          return hasLoginAnnotation && hasMemberType;
      }
      
			@Override
      public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
					
					log.info("resolveArgument 실행");
          HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();
          HttpSession session = request.getSession(false);
          if (session == null) {
              return null;
          }
          return session.getAttribute(SessionConst.LOGIN_MEMBER);
      }
}
```

```java
// 등록
@Configuration
public class WebConfig implements WebMvcConfigurer {
			
			@Override
      public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
          resolvers.add(new LoginMemberArgumentResolver());
      }
      
			//...
}
```


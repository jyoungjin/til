## 04. 검증2 - Bean Validation

----

##### Bean Validation - 소개

- 검증 기능을 지금처럼 매번 코드로 작성하는 것은 상당히 번거롭다. 
  특히 특정 필드에 대한 검증 로직은 대부분 빈 값인지 아닌지, 특정 크기를 넘는지 아닌지와 같이 매우 일반적인 로직이다.

- ```java
  public class Item {
  
        private Long id;
        
        @NotBlank
        private String itemName;
        
        @NotNull
        @Range(min = 1000, max = 1000000)
        private Integer price;
    
        @NotNull
        @Max(9999)
        private Integer quantity;
        //...
  }
  ```



**Bean Validation**

- **먼저 Bean Validation은 특정한 구현체가 아니라 Bean Validation 2.0(JSR-380)이라는 기술 표준이다.**
- **검증 애노테이션과 여러 인터페이스의 모음이다.**
- Bean Validation을 구현한 기술중에 일반적으로 사용하는 구현체는 **하이버네이트 Validator**이다. 
  이름이 하이버네이트가 붙어서 그렇지 ORM과는 관련이 없다.

**하이버네이트** **Validator** 관련 링크

- 공식 사이트: http://hibernate.org/validator/
- 공식 메뉴얼: https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/
- 검증 애노테이션 모음: https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/ html_single/#validator-defineconstraints-spec



##### Bean Validation - 시작

- Bean Validation 의존관계 추가

  - ```properties
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    ```

- 검증 애노테이션

  - @NotBlank : 빈값 + 공백만 있는 경우를 허용하지 않는다.
  - @NotNull : null 을 허용하지 않는다.
  - @Range(min = 1000, max = 1000000) : 범위 안의 값이어야 한다.
  - @Max(9999) : 최대 9999까지만 허용한다.

- 스프링 MVC는 어떻게 Bean Validator를 사용?

  - 스프링 부트가 spring-boot-starter-validation 라이브러리를 넣으면 자동으로 Bean Validator를 인지하고 스프링에 통합한다.

- LocalValidatorFactoryBean 을 글로벌 Validator로 등록한다. 
  이 Validator는 @NotNull 같은 애노테이션을 보고 검증을 수행한다. 
  이렇게 글로벌 Validator가 적용되어 있기 때문에, **@Valid , @Validated** 만 적용하면 된다.
  검증 오류가 발생하면, FieldError , ObjectError 를 생성해서 BindingResult 에 담아준다.

>검증시 @Validated @Valid 둘다 사용가능하다.
>javax.validation.@Valid 를 사용하려면 build.gradle 의존관계 추가가 필요하다.
>implementation 'org.springframework.boot:spring-boot-starter-validation'
>**@Validated 는 스프링 전용 검증 애노테이션이고, @Valid 는 자바 표준 검증 애노테이션**이다. 
>둘중 아무거나 사용해도 동일하게 작동하지만, @Validated 는 내부에 groups 라는 기능을 포함하고 있다. 

##### 검증 순서

1. @ModelAttribute 각각의 필드에 타입 변환 시도
   1. 성공하면 다음으로
   2. 실패하면 typeMismatch로 FieldError 추가
2. Validator 적용



**바인딩에 성공한 필드만** **Bean Validation** 적용

- BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않는다.
- 생각해보면 타입 변환에 성공해서 바인딩에 성공한 필드여야 BeanValidation 적용이 의미 있다. 
  (일단 모델 객체에 바인딩 받는 값이 정상으로 들어와야 검증도 의미가 있다.)
- @ModelAttribute 각각의 필드 타입 변환시도 변환에 성공한 필드만 BeanValidation 적용
- 예시
  - itemName 에 문자 "A" 입력 타입 변환 성공 itemName 필드에 BeanValidation 적용
  - price 에 문자 "A" 입력 "A"를 숫자 타입 변환 시도 실패 typeMismatch FieldError 추가 -> price 필드는 BeanValidation 적용 X



##### Bean Validation - 에러 코드

- Bean Validation이 기본으로 제공하는 오류 메시지를 좀 더 자세히 변경하고 싶으면 어떻게 하면 될까?

- 메시지 등록

- ```properties
  #Bean Validation 추가 
  NotBlank={0} 공백X 
  Range={0}, {2} ~ {1} 허용 
  Max={0}, 최대 {1}
  ```

- **BeanValidation** 메시지 찾는 순서

  - 생성된 메시지 코드 순서대로 messageSource 에서 메시지 찾기
  - 애노테이션의 message 속성 사용 @NotBlank(message = "공백! {0}")
  - 라이브러리가 제공하는 기본 값 사용 공백일 수 없습니다.



##### Bean Validation - 오브젝트 오류

- ```java
  @Data
  @ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity >= 10000", message = "총합이 10000원 넘게 입력해주세요.")
  public class Item {
  //...
  }
  ```

- 메시지 코드

  - ScriptAssert.item
  - ScriptAssert

- 그런데 실제 사용해보면 제약이 많고 복잡하다. 
  그리고 실무에서는 검증 기능이 해당 객체의 범위를 넘어서는 경우들도 종종 등장하는데, 그런 경우 대응이 어렵다.

- 따라서 오브젝트 오류(글로벌 오류)의 경우 @ScriptAssert 을 억지로 사용하는 것 보다는 
  다음과 같이 오브젝트 오류 관련 부분만 직접 자바 코드로 작성하는 것을 권장한다.



##### Bean Validation - 한계

- 현재 구조에서는 수정시 item 의 id 값은 항상 들어있도록 로직이 구성되어 있다. 그래서 검증하지 않아도 된다고 생각할 수 있다. 
  그런데 HTTP 요청은 언제든지 악의적으로 변경해서 요청할 수 있으므로 서버에서 항상 검증해야 한다. 
  예를 들어서 HTTP 요청을 변경해서 item의 id 값을 삭제하고 요청할 수도 있다. 따라서 최종 검증은 서버에서 진행하는 것이 안전한다.
- 방법 2가지
  1. BeanValidation의 groups 기능을 사용한다.
  2. Item을 직접 사용하지 않고, ItemSaveForm, ItemUpdateForm 같은 폼 전송을 위한 별도의 모델 객체를 만들어서 사용한다.



##### Bean Validation - groups

- 동일한 모델 객체를 등록할 때와 수정할 때 각각 다르게 검증하는 방법을 알아보자.
- groups 기능을 사용해서 등록과 수정시에 각각 다르게 검증을 할 수 있었다. 
  그런데 groups 기능을 사용하니 Item 은 물론이고, 전반적으로 복잡도가 올라갔다.
  사실 groups 기능은 실제 잘 사용되지는 않는데, 
  그 이유는 실무에서는 주로 다음에 등장하는 등록용 폼 객체와 수정용 폼 객체를 분리해서 사용하기 때문이다.

>참고: @Valid 에는 groups를 적용할 수 있는 기능이 없다. 따라서 groups를 사용하려면 @Validated 를 사용해야 한다.



##### Form 전송 객체 분리

1. **폼 데이터 전달에** **Item** **도메인 객체 사용**
   - HTML Form -> Item -> Controller -> Item -> Repository
   - 장점: Item 도메인 객체를 컨트롤러, 리포지토리 까지 직접 전달해서 중간에 Item을 만드는 과정이 없어서 간단하다.
   - 단점: 간단한 경우에만 적용할 수 있다. 수정시 검증이 중복될 수 있고, groups를 사용해야 한다.
2. **폼 데이터 전달을 위한 별도의 객체 사용**
   - HTML Form -> ItemSaveForm -> Controller -> Item 생성 -> Repository
   - 장점: 전송하는 폼 데이터가 복잡해도 거기에 맞춘 별도의 폼 객체를 사용해서 데이터를 전달 받을 수 있다. 
     보통 등록과, 수정용으로 별도의 폼 객체를 만들기 때문에 검증이 중복되지 않는다.
   - 단점: 폼 데이터를 기반으로 컨트롤러에서 Item 객체를 생성하는 변환 과정이 추가된다.

>**Q:** **이름은 어떻게 지어야 하나요**?
>이름은 의미있게 지으면 된다. 
>ItemSave 라고 해도 되고, ItemSaveForm , ItemSaveRequest , ItemSaveDto 등으로 사용해도 된다. 
>중요한 것은 일관성이다.
>
>**Q:** **등록**,**수정용 뷰 템플릿이 비슷한데 합치는게 좋을까요**?
>한 페이지에 그러니까 뷰 템플릿 파일을 등록과 수정을 합치는게 좋을지 고민이 될 수 있다. 
>각각 장단점이 있으므로 고민하는게 좋지만, 어설프게 합치면 수 많은 분기문(등록일 때, 수정일 때) 때문에 나중에 유지보수에서 고통을 맛본다.
>이런 어설픈 분기문들이 보이기 시작하면 분리해야 할 신호이다.



##### Bean Validation - HTTP 메시지 컨버터

- @Valid , @Validated 는 HttpMessageConverter ( @RequestBody )에도 적용할 수 있다.

>@ModelAttribute는 HTTP 요청 파라미터(URL 쿼리 스트링, POST Form)를 다룰 때 사용한다.
>@RequestBody는 HTTP Body의 데이터를 객체로 변환할 때 사용한다. 주로 API JSON 요청을 다룰 때 사용한다.

- **API의 경우 3가지 경우**를 나누어 생각해야 한다.
  1. 성공 요청: 성공
  2. 실패 요청: JSON을 객체로 생성하는 것 자체가 실패함
  3. 검증 오류 요청: JSON을 객체로 생성하는 것은 성공했고, 검증에서 실패함



##### **@ModelAttribute vs @RequestBody**

- @ModelAttribute 는 필드 단위로 정교하게 바인딩이 적용된다. 
  특정 필드가 바인딩 되지 않아도 나머지 필드는 정상 바인딩 되고, Validator를 사용한 검증도 적용할 수 있다.
- @RequestBody 는 HttpMessageConverter 단계에서 JSON 데이터를 객체로 변경하지 못하면 이후 단계 자체가 진행되지 않고 예외가 발생한다.
  컨트롤러도 호출되지 않고, Validator도 적용할 수 없다.

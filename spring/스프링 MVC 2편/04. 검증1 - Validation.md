## 04. 검증1 - Validation

----

##### 클라이언트 검증, 서버 검증

- 클라이언트 검증은 조작할 수 있으므로 보안에 취약하다.
- 서버만으로 검증하면, 즉각적인 고객 사용성이 부족해진다.
- 둘이 적절히 섞어서 사용하되, 최종적으로 서버 검증은 필수.
- API 방식을 사용하면 API 스펙을 잘 정의해서 검증 오류를 API 응답 결과에 잘 남겨주어야 함.



##### Safe Navigation Operator

- errors?. 은 errors 가 null 일때 NullPointerException 이 발생하는 대신, null 을 반환하는 문법이다.
- th:if 에서 null 은 실패로 처리되므로 오류 메시지가 출력되지 않는다.



##### BindingResult

- 주의: **BindingResult bindingResult 파라미터의 위치는 @ModelAttribute Item item 다음에 와야 한다.**

- 필드 오류 - FieldError

  ```java
  if (!StringUtils.hasText(item.getItemName())) { 
  			bindingResult.addError(new FieldError("item", "itemName", "상품 이름은 필수입니다."));
  }
  ```

- FieldError 생성자 요약

  ```java
  // objectName : @ModelAttribute 이름, field : 오류가 발생한 필드 이름, defaultMessage : 오류 기본 메시지
  public FieldError(String objectName, String field, String defaultMessage) {}
  ```

- 글로벌 오류 - ObjectError

  ```java
  bindingResult.addError(new ObjectError("item", "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice));
  ```



##### 타임리프 스프링 검증 오류 통합 기능

- 타임리프는 스프링의 BindingResult 를 활용해서 편리하게 검증 오류를 표현하는 기능을 제공한다.
- \#fields : #fields 로 BindingResult 가 제공하는 검증 오류에 접근할 수 있다.
- th:errors : 해당 필드에 오류가 있는 경우에 태그를 출력한다. th:if 의 편의 버전이다.
- th:errorclass : th:field 에서 지정한 필드에 오류가 있으면 class 정보를 추가한다.
- https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html#validation-and-error-messages



##### @ModelAttribute에 바인딩 시 타입 오류가 발생하면?

- **BindingResult**가 없으면 -> 400 에러가 발생하면서 컨트롤러가 호출되지 않고, 오류 페이지로 이동한다.
- **BindingResult**가 있으면 -> 오류 정보(FileError)를 BindingResult에 담아서 컨트롤러를 정상 호출한다.



##### BindingResult에 검증 오류를 적용하는 3가지 방법

1. @ModelAttribute 의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이 FieldError 생성해서 BindingResult 에 넣어준다.
2. 개발자가 직접 넣어준다.
3. Validator 사용 이것은 뒤에서 설명4



##### FieldError, ObjectError

- ```java
  // FiledError 생성자
  public FieldError(String objectName, String field, String defaultMessage);
  public FieldError(String objectName, String field, @Nullable Object rejectedValue, boolean bindingFailure, @Nullable String[] codes, @Nullable Object[] arguments, @Nullable String defaultMessage)
  ```

- objectName : 오류가 발생한 객체 이름
  field : 오류 필드
  rejectedValue : 사용자가 입력한 값(거절된 값)
  bindingFailure : 타입 오류 같은 바인딩 실패인지, 검증 실패인지 구분 값
  codes : 메시지 코드
  arguments : 메시지에서 사용하는 인자
  defaultMessage : 기본 오류 메시지

- ```java
  // ObjectError 생성자
  new ObjectError("item", null, null, "가격 * 수량의 합은 10,000원 이상이어야 합니다. 현재 값 = " + resultPrice)
  ```



##### 오류 코드와 메시지 처리1

- FieldError , ObjectError 의 생성자는 **codes , arguments** 를 제공한다. 이것은 오류 발생시 오류 코드로 메시지를 찾기 위해 사용된다.
- codes : required.item.itemName 를 사용해서 메시지 코드를 지정한다. 메시지 코드는 하나가 아니라 배열로 여러 값을 전달할 수 있는데, 
  순서대로 매칭해서 처음 매칭되는 메시지가 사용된다.
- arguments : Object[]{1000, 1000000} 를 사용해서 코드의 {0} , {1} 로 치환할 값을 전달한다.

##### 오류 코드와 메시지 처리2

- BindingResult 가 제공하는 **rejectValue() , reject()** 를 사용하면 
  FieldError , ObjectError 를 직접 생성하지 않고, 깔끔하게 검증 오류를 다룰 수 있다.

- **rejectValue()**

  - field : 오류 필드명

  - errorCode : 오류 코드(이 오류 코드는 메시지에 등록된 코드가 아니다. 뒤에서 설명할 messageResolver를 위한 오류 코드이다.)

  - errorArgs : 오류 메시지에서 {0} 을 치환하기 위한 값

  - defaultMessage : 오류 메시지를 찾을 수 없을 때 사용하는 기본 메시지

    ```java
      bindingResult.rejectValue("price", "range", new Object[]{1000, 1000000}, null)
    ```

- **축약된 오류 코드**

  - FieldError() 를 직접 다룰 때는 오류 코드를 range.item.price 와 같이 모두 입력했다. 그런데 rejectValue() 를 사용하고 부터는 오류 코드를 range 로 간단하게 입력했다. 그래도 오류 메시지를 잘 찾아서 출력한다. 무언가 규칙이 있는 것 처럼 보인다. 이 부분을 이해하려면 MessageCodesResolver 를 이해해야 한다.

##### 오류 코드와 메시지 처리3

- required.item.itemName : 상품 이름은 필수 입니다. -> required : 필수 값 입니다.

-  **가장 좋은 방법은 범용성으로 사용하다가, 세밀하게 작성해야 하는 경우에는 세밀한 내용이 적용되도록 메시지에 단계를 두는 방법이다.**

- ```yaml
  #Level1
  required.item.itemName: 상품 이름은 필수 입니다. 
  
  #Level2
  required: 필수 값 입니다.
  ```

- 스프링은 **MessageCodesResolver** 라는 것으로 이러한 기능을 지원한다.

##### 오류 코드와 메시지 처리4

- **DefaultMessageCodesResolver의 기본 메시지 생성 규칙**

- ```java
  객체 오류
  객체 오류의 경우 다음 순서로 2가지 생성 
  1.: code + "." + object name 
  2.: code
  
  예) 오류 코드: required, object name: item 
  1.: required.item
  2.: required
  ```

- ```java
  필드 오류
  필드 오류의 경우 다음 순서로4가지 메시지 코드 생성
  1.: code + "." + object name + "." + field
  2.: code + "." + field
  3.: code + "." + field type
  4.: code
  
  예) 오류 코드: typeMismatch, object name "user", field "age", field type: int 
  1. "typeMismatch.user.age"
  2. "typeMismatch.age"
  3. "typeMismatch.int"
  4. "typeMismatch"
  ```

- **동작 방식**

  - rejectValue() , reject() 는 내부에서 MessageCodesResolver 를 사용한다. 여기에서 메시지 코드들을 생성한다.
  - FieldError , ObjectError 의 생성자를 보면, 오류 코드를 하나가 아니라 여러 오류 코드를 가질 수 있다. 
    MessageCodesResolver 를 통해서 생성된 순서대로 오류 코드를 보관한다.

##### 오류 코드와 메시지 처리5

- 오류 코드 관리 전략

  - **핵심은 구체적인 것에서 덜 구체적인 것으로!**

  - 크게 중요하지 않은 메시지는 범용성 있는 requried 같은 메시지로 끝내고, 
    정말 중요한 메시지는 꼭 필요할 때 구체적으로 적어서 사용하는 방식이 더 효과적이다.

  - ```properties
    #required.item.itemName=상품 이름은 필수입니다. 
    #range.item.price=가격은 {0} ~ {1} 까지 허용합니다. 
    #max.item.quantity=수량은 최대 {0} 까지 허용합니다. 
    #totalPriceMin=가격 * 수량의 합은 {0}원 이상이어야 합니다. 현재 값 = {1}
    
    #==ObjectError==
    #Level1
    totalPriceMin.item=상품의 가격 * 수량의 합은 {0}원 이상이어야 합니다. 현재 값 = {1}
    #Level2 - 생략
    totalPriceMin=전체 가격은 {0}원 이상이어야 합니다. 현재 값 = {1}
    
    #==FieldError==
    #Level1
    required.item.itemName=상품 이름은 필수입니다. range.item.price=가격은 {0} ~ {1} 까지 허용합니다. max.item.quantity=수량은 최대 {0} 까지 허용합니다.
          
    #Level2 - 생략
    
    #Level3
    required.java.lang.String = 필수 문자입니다. required.java.lang.Integer = 필수 숫자입니다. min.java.lang.String = {0} 이상의 문자를 입력해주세요. min.java.lang.Integer = {0} 이상의 숫자를 입력해주세요. range.java.lang.String = {0} ~ {1} 까지의 문자를 입력해주세요. range.java.lang.Integer = {0} ~ {1} 까지의 숫자를 입력해주세요. 
    max.java.lang.String = {0} 까지의 문자를 허용합니다. max.java.lang.Integer = {0} 까지의 숫자를 허용합니다.
    
    #Level4
    required = 필수 값 입니다.
    min= {0} 이상이어야 합니다.
    range= {0} ~ {1} 범위를 허용합니다. max= {0} 까지 허용합니다.
    ```

##### 오류 코드와 메시지 처리6

- 검증 오류 코드 2가지

  - 개발자가 직접 설정한 오류 코드 rejectValue() 를 직접 호출
  - 스프링이 직접 검증 오류에 추가한 경우(주로 타입 정보가 맞지 않음)

- **스프링이 직접 만든 오류 메시지 처리**

  - typeMismatch.item.price
  - typeMismatch.price
  - typeMismatch.java.lang.Integer
  - typeMismatch

- ```properties
  #추가
  typeMismatch.java.lang.Integer=숫자를 입력해주세요. 
  typeMismatch=타입 오류입니다.
  ```



##### Validator 분리1

- ```java
  public interface Validator {
    	// supports() {} : 해당 검증기를 지원하는 여부 확인
      boolean supports(Class<?> clazz);
    	// validate(Object target, Errors errors) : 검증 대상 객체와 BindingResult
      void validate(Object target, Errors errors);
  }
  ```

##### Validator 분리2

- 스프링이 Validator 인터페이스를 별도로 제공하는 이유는 체계적으로 검증 기능을 도입하기 위해서다. 
  그런데 앞에서는 검증기를 직접 불러서 사용했고, 이렇게 사용해도 된다. 
  그런데 Validator 인터페이스를 사용해서 검증기를 만들면 스프링의 추가적인 도움을 받을 수 있다.

- ```java
  // @InitBinder 해당 컨트롤러에만 영향을 준다. 글로벌 설정은 별도로 해야한다.
  @InitBinder
  public void init(WebDataBinder dataBinder) {
          dataBinder.addValidators(itemValidator);
  }
  ```

- @Validated 는 검증기를 실행하라는 애노테이션이다.

- 이 애노테이션이 붙으면 앞서 WebDataBinder 에 등록한 검증기를 찾아서 실행한다. 
  그런데 여러 검증기를 등록한다면 그 중에 어떤 검증기가 실행되어야 할지 구분이 필요하다. 이때 supports() 가 사용된다.
  여기서는 supports(Item.class) 호출되고, 결과가 true 이므로 ItemValidator 의 validate() 가 호출된다.



##### 글로벌 설정 - 모든 컨트롤러에 다 적용

```java
@SpringBootApplication
  public class ItemServiceApplication implements WebMvcConfigurer {
      
    	public static void main(String[] args) {
          SpringApplication.run(ItemServiceApplication.class, args);
			}
    
      @Override
      public Validator getValidator() {
          return new ItemValidator();
      }
}
```

- **@Validated 는 스프링 전용 검증 애노테이션이고, @Valid 는 자바 표준 검증 애노테이션이다.**

## 프로세스의 메모리 구조

----

##### 프로세스의 메모리 구조

- 운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당합니다. 
  위에서부터 스택(stack), 힙(heap), 데이터 영역(BSS segment, Data segment), 코드 영역(code segment)으로 나눠집니다. 
  스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당 됩니다.
  - 스택 (동적)
    - 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정됩니다. 그러나 함수가 함수를 호출 하는 등에 따라 런타임시에도 크기가 변경됩니다.
  - 힙 (동적)
    - 힙은 동적 할당할 때 사용되며 런타임 시 크기가 결정됩니다.
  - 데이터 영역 (정적)
    - BSS 영역과 Data 영역으로 나뉘고 정적할당에 관한 부분을 담당합니다.
  - 코드 영역 (정적)
    - 소스코드 들어감.
- 정적할당
  - 정적할당은 컴파일단계에서 메모리를 할당하는 것을 말합니다. 
    BSS segment와 Data segment, code / text segment 로 나뉘어서 저장됩니다.
    - BSS segment는 전역변수,static, const로 선언되어있는 변수 중 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 이 메모리 영역에 할당됩니다.
    - Data segment은 전역변수, static, const로 선언되어있는 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당됩니다.
    - code / text segment는 프로그램의 코드가 들어갑니다.
- 동적할당
  - 동적할당은 런타임단계에서 메모리를 할당받는 것이며 Stack과 Heap으로 나눠집니다.
    - Stack
      - Stack은 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역입니다. 함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 stack에 계속해서 저장됩니다.
        참고로 재귀함수가 호출된다고 했을 때 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않습니다.
    - Heap
      - Heap은 동적으로 할당되는 변수들을 담습니다. malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료구조의 경우 Heap영역을 사용합니다. 예를 들어 vector는 내부적으로 heap영역을 사용합니다.



##### PCB와 컨텍스트 스위칭

- PCB(Process Control Block)는 운영체제에서 프로세스에 대한 메타데이터를 저장한 ‘데이터’
  - 프로세스가 생성되면 운영체제는 해당 PCB를 생성합니다.
    프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 앞서 설명한 스택, 힙 등의 구조를 기반으로 메모리가 할당됩니다.
    그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리됩니다. 이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리됩니다.
  - PCB의 구조
    - 프로세스 스케줄링 상태: 준비, 일시중단 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
    - 프로세스 ID: 프로세스 ID, 해당 프로세스의 자식 프로세스 ID
    - 프로세스 권한: 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
    - 프로그램 카운터: 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
    - CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    - 계정 정보: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
    - I/O 상태 정보: 프로세스에 할당된 I/O 디바이스 목록
- 컨텍스트 스위칭: PCB를 교환하는 과정
  - 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생합니다.
    컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 단 한개이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문입니다.
    참고로 사실 현대 컴퓨터는 멀티 코어의 CPU를 가지기 때문에 한 시점에 한 개의 프로그램이라는 설명은 틀린 설명입니다. 하지만 컨텍스트 스위칭을 설명할 때는 싱글코어를 기준으로 설명합니다.
  - 한 개의 프로세스 A가 실행하다 멈추고, 프로세스 A의 PCB를 저장하고 다시 프로세스 B를 로드하여 실행합니다. 그리고 다시 프로세스 B의 PCB를 저장하고 프로세스 A의 PCB를 로드합니다. 컨텍스트 스위칭이 일어날 때 다음 그림처럼 유휴 시간(idletime)이 발생하는 것을 볼 수 있습니다. 이뿐만 아니라 이 컨텍스트 스위칭에 드는 비용이 더 있습니다. 바로 캐시미스입니다.
  - 비용: 캐시미스
    - 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로  캐시 클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생합니다.
  - 스레드에서의 컨텍스트 스위칭
    - 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 더 적고 시간도 더 적게 걸립니다.

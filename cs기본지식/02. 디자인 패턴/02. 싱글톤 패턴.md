## 싱글톤 패턴

----

##### 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

- 데이터베이스 연결모듈에 많이 쓰임. 

- 인스턴스 생성에 장점. 

- 의존성이 높아지고, TDD에 단점

- 장점

  - 하나의 인스턴스를 기반으로 해당 인스턴스를 다른 모듈들이 공유하여 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어듭니다.
    그렇기 때문에 "인스턴스 생성에 많은 비용"이 드는 I/O 바운드 작업에 많이 사용합니다.

- 단점

  - 의존성이 높아지며 TDD를 할 때 걸림돌이 됩니다. TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 합니다.
    하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵습니다.

- >I/O 바운드: 디스크 연결, 네트워크 통신, 데이터베이스 연결
  >
  >의존성: 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미합니다.

```js
// 싱글톤이 아닌 클래스
class Rectangle {
    constructor(height, width) {
      this.height = height;
      this.width = width; }
}
const a = new Rectangle(1, 2) 
const b = new Rectangle(1, 2) 
console.log(a === b) // false

// 싱글톤 패턴 - DB 연결 모듈
const URL = 'mongodb://localhost:27017/kundolapp'
const createConnection = url => ({"url" : url})
class DB {
    constructor(url) {
        if (!DB.instance) {
            DB.instance = createConnection(url)
        }
        return DB.instance
    }
    connect() {
        return this.instance
} }
const a = new DB(URL)
const b = new DB(URL) 
console.log(a === b) // true

// java
class Singleton {
		private static class singleInstanceHolder {
				private static final Singleton INSTANCE = new Singleton(); 
    }
    public static Singleton getInstance() { 
      return singleInstanceHolder.INSTANCE;
		} 
}

/*
705927765
705927765
true
1. 클래스안에 클래스(Holder), static이며 중첩된 클래스인 singleInstanceHolder를 기반으로 객체를 선언했기 때문에 한 번만 로드되므로 싱글톤 클래스의 인스턴스는 애플리케이션 당 하나만 존재하며 클래스가 두 번 로드되지 않기 때문에 두 스레드가 동일한 JVM에서 2개의 인스턴스를 생성할 수 없습니다.
그렇기 때문에 동기화, 즉 synchronized를 신경쓰지 않아도 됩니다.
2. final 키워드를 통해서 read only 즉, 다시 값이 할당되지 않도록 했습니다.
3. 중첩클래스 Holder로 만들었기 때문에 싱글톤 클래스가 로드될 때 클래스가 메모리에 로드되지 않고 어떠한 모듈에서 getInstance()메서드가 호출할 때 싱글톤 객체를 최초로 생성 및 리턴하게 됩니다.
*/
public class HelloWorld{
  public static void main(String []args){
		  Singleton a = Singleton.getInstance(); 
    	Singleton b = Singleton.getInstance(); 
    	System.out.println(a.hashCode()); 
    	System.out.println(b.hashCode());
		  if (a == b){ 
        	System.out.println(true);
      } 
   }
}
```


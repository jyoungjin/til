## 부록

---

##### [부록] 의존성주입과 전략패턴의 차이

- 의존성주입이나 전략패턴 모두 "무언가를 쉽게 교체하기 위한 디자인패턴"이며 같은 방식으로 작동합니다.
- 차이
  - 전략패턴: 의도에 초점을 맞추고 동일한 행동 계약을 준수하는 다양한 구현으로 인터페이스를 만들도록 권장하는 것을 포함
  - 의존성주입: 단지 일부 동작을 구현하고 의존성을 주입하기만 하는 패턴입니다.



##### [부록] 컨텍스트란?

- 뜻
  1. 어떤 종류의 상태, 환경을 캡슐화한 것을 말함.
  2. 작업이 중단 되고 나중에 같은 지점에서 계속 될 수 있도록 저장하는 최소 데이터 집합. (컨텍스트스위칭)
- 컨텍스트는 context와 contextual information으로 크게 나눠지는데 다음과 같습니다.
  - 병원에 가면 “이름”과 주민등록번호 앞자리를 말해야죠? 자 여기서 “병원에 방문”하는 context에서 여러분의 이름은 contextual information이 됩니다.
  - HTTP요청을 하는 context에서 HTTP Header는 contextual inforamation이라고 할 수 있습니다.
  - 트랜잭션이라는 context에서 트랜잭션 ID가 contextual information 이라고 할 수 있습니다.



##### [부록] 자바스크립트의 class

- 클래스: 객체를 생성하기 위한 템플릿

  - 자바스크립트는 원래 prototype이라는 것을 기반으로 생성했지만 ES5부터는 class라는 키워드로 클래스를 선언할 수 있습니다.
  - 클래스 >> 객체 >> 인스턴스
    - 인스턴스: 컴퓨터 메모리 위에 올라간 객체

- constructor

  - 개체 초기화를 위한 메서드, class에는 constructor 한개만 가능.

  - ```javascript
    class Rectangle {
      constructor(height, width) {
    		this.height = height;
    		this.width = width; 
      }
    }
    const p = new Rectangle();
    ```

- static

  - 클래스에 대한 정적 메서드 또는 속성을 정의하며 클래스의 인스턴스에서 호출이 불가함.

    1. 중복되는 함수, 데이터를 정의할 때 쓰임(메모리 이점)
    2. 이 클래스의 객체들끼리 사용되는 메서드나 속성이다. 라는 명시성이라는 장점이 있음.

  - ```javascript
    class Point { 
    	constructor(x, y) {
    		this.x = x;
    		this.y = y; 
      }
    	static displayName = "Point"; 
    	static distance(a, b) {
    		const dx = a.x - b.x; 
    		const dy = a.y - b.y; 
    		return Math.hypot(dx, dy);
    	} 
    }
    ```

- **Q. static 변수를 자주 사용하게 되었을 때 단점은 뭘까요?**

  - static은 일종의 전역변수라 전역변수의 단점 일부를 가지고 있습니다.
  - but, 전역변수와는 다르게 get, set 함수를 만들 수 있습니다.(전역변수보다는 조금 더 간접접근을 할 수 있습니다.) 
    클래스에서 사용된다는 명시성을 가진다는 점 등이 다릅니다.

  1. 동시성 문제 : 여러 스레드에서 해당 전역변수를 참조하게 된다고 보죠.
     만약 해당 static 변수가 변경되었을 때 다른 모든 스레드에 영향을 주기 때문에 사이드 이펙트가 일어나 안전하지 않을 수 있습니다.
  2. 메모리 문제 : 클래스가 생성될 때 메모리를 할당, 그리고 프로그램 종료시점에 반환되므로 사용하지 않아도 메모리가 할당되어있음. 
     근데 만약에 이걸 객체에다가 집어넣은 메서드의 경우 사용하지 않을 경우에는 메모리 할당이 일어나지 않음.
  3. 테스트 문제 : 단위테스트를 한다고 하면 해당 메서드, 함수만을 실행해야 하는데 static으로 한 경우 단위적이지 않고 전역적으로 관리되기 때문에 해당 부분을 깨끗하게 테스팅하기가 어렵습니다.

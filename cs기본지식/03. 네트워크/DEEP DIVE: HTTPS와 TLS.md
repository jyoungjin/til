## DEEP DIVE: HTTP와 TLS

---

##### #1. 암호화

- 암호화는 승인된 당사자만 정보를 이해할 수 있도록 데이터를 “스크램블”한 방법입니다. 
  이를 복호화하려면 송신자와 수신자가 서로 동의한 “키”가 필요합니다. 또한 이를 만들기 위해 키가 쓰이기도 합니다. 
  ciphertext = plaintext + key
- 스크램블
  - 각 단어나 문자를 패턴에 따라 암호화하는 것이 아니라 무작위 방식으로 개별 데이터 비트를 섞는 것을 말합니다.
- 예를 들어, 공통 128비트 고급 암호화 표준(Advanced Encryption Standard, AES)으로 암호화된 파일의 경우 이 파일을 구성하는 비트는 약 10회 스크램블되며 다른 컴퓨터가 키 없이 해독하려면 아주 오랜 시간이 걸립니다. 비트가 높아질수록 스크램블을 많이 하게 되고 더 복잡해지는 것인데 이 128비트는 AES의 가장 약한 버전입니다. 192비트 및 256비트 키 크기도 제공됩니다.
- 대칭 암호화
  - 키를 하나만 사용하는 암호화 방법입니다. 
  - 예를 들어 "hello"라는 텍스트를 키로 암호화한다고 해봅시다. 동일한 키로 암호를 해독해서 hello를 반환한 것을 볼 수 있습니다.
    Plaintext + key = ciphertext: hello + 2jd8932kd8 = X5xJCSycg14=
    Ciphertext + key = plaintext: X5xJCSycg14= + 2jd8932kd8 = hello
- 비대칭 암호화 (cost가 더 많이 듬)
  - 공개키 암호화라고도 합니다.
  - 공개 키 암호화는 두 개의 다른 키(공개키, 개인키)로 데이터를 암호화하거나 서명하고 키 중 하나인 공개 키를 누구나 사용할 수 있도록 하는 방법입니다. 공개키로 암호화된 데이터는 개인키로만 복호화할 수 있게 합니다. 일반적으로 사용되는 비대칭 암호화 알고리즘은 RSA, DH(Die–Hellman) 이 있습니다.
    HTTPS를 가능하게 하는 프로토콜인 TLS는 부분적으로 비대칭 암호화를 씁니다. (TLS1.3) 비대칭암호화로 인증을 한 후, 대칭 암호화로 보안적 통신을 시작합니다.
    **TLS 핸드셰이크 과정에서 처음 인증할 때 비대칭 암호화**를 하고 **그 이후 클라이언트와 서버는 "세션키"라고 하는 키를 기반으로 대칭 암호화**를 기반으로 암호화된 통신을 합니다.
- 암호화의 필요성
  - 암호화는 의도된 수신자 또는 송신자를 제외하고는 통신을 하이재킹하여 읽을 수 없게 합니다. 이를 통해 민감한 데이터의 유출을 방지하고 데이터 무결성을 보장합니다.



##### #2. TLS 핸드셰이크

- SSL(Secure Socket Layer)은 SSL 1.0부터 시작해서 SSL 2.0, SSL 3.0, TLS(TransportLayer Security Protocol) 1.0, TLS 1.3까지 버전이 올라가며 마지막으로 TLS로 명칭이 변경되었습니다. 여기서는 TLS 1.3을 기반으로 설명합니다.
  TLS은 전송 계층에서 보안을 제공하는 프로토콜입니다. 클라이언트와 서버가 통신 할 때 TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 합니다.

1. Client Hello
   - 클라이언트는 TLS 버전, 사이퍼 슈트와 클라이언트 랜덤값(무작위 문자열), 임시 DH 매개변수를 서버에게 보냅니다.
2. Server Hello, EncryptedExtensions, Certificate, CertificateVerify
   - 서버는 클라이언트로부터 받은 옵션을 확인합니다.
     서버와 클라이언트 모두에서 지원하는 가장 높은 TLS 버전을 식별하며 결정, 사이퍼슈트 지원 여부를 확인합니다.
     공개키가 포함된 SSL 인증서, 서버 랜덤값, 임시 DH 매개변수를 보냅니다. 
     그리고 클라이언트와 서버 각각 서로 교환한 DH 매개변수를 사용하여 임시 암호 키(세션키)를 생성합니다.
3. Finished
   - 클라이언트와 서버와 세션키를 기반으로 대칭 암호화된 통신이 시작됩니다. (보안 세션이 시작되었다고도 합니다.)

- 키교환 알고리즘으로는 대표적으로 RSA, DH가 있습니다.
  여기서는 DH를 기반으로 설명합니다. TLS 1.3 버전에서는 RSA 같은 경우 취약점이 있기 때문에 공식적으로 지원하지 않습니다.
  DH의 경우 타원곡선 DH를 사용합니다.

- **DH 매개변수**
  - DH는 Diffie-Hellman을 의미합니다. 
    Diffie-Hellman 알고리즘은 서로 공개값 공유, 비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는 알고리즘입니다.
  - 타원곡선 암호화 방법
    - 곡선을 사용하여 개인 키 보유자만 알 수 있는 타원곡선을 그립니다. 이걸 기반으로 교차점을 생성합니다.
      이 교차점의 수를 기반으로 암호를 설정하는 방법을 말합니다.
- 사이퍼슈트
  - 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며 암호제품군이라고도 불립니다.
  - 예를 들어 TLS_AES_128_GCM_SHA256에는 세 가지 규약이 들어 있음을 뜻합니다.
    - TLS는 프로토콜
    - AES_128_GCM은 AEAD 사이퍼 모드
    - SHA256은 해싱 알고리즘
  - AEAD 사이퍼 모드
    - AEAD(Authenticated Encryption with Associated Data)는 데이터 암호화 알고리즘이며 AES_128_GCM 등이 있습니다. 
      예를 들어 AES_128_GCM이라는 것은 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM이 결합된 알고리즘을 뜻합니다.
  - 해싱 알고리즘
    - 해싱 알고리즘은 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘입니다. 
      SSL/TLS는 해싱 알고리즘으로 SHA-256 알고리즘과 SHA-384 알고리즘을 쓰는데, 그 중 많이 쓰는 SHA-256 알고리즘을 설명하겠습니다. 
      SHA-256 알고리즘은 해시 함수의 결괏값이 256비트인 알고리즘이며 비트 코인을 비롯한 많은 블록체인 시스템에서도 씁니다.
- 인증서
  - 인증서는 1. 주체(인증서 발급한 CA, 도메인, 웹사이트 소유자, 인증서 소유자), 2. 공개키(공개키, 공개키암호화방법)를 포함하는 단순한 데이터 파일입니다. 
    자신의 웹사이트 안에서 SSL 인증서를 만들 수도 있지만 보통은 인증기관인 CA에서 발급한 SSL인증서를 기반으로 인증작업을 수행합니다.
    주체는 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 확인할 때 쓰이고 공개키는 처음 인증작업을 수행할 때 쓰입니다.
- CA
  - 인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 합니다. 
    이 인증서를 발급하는 기업들을 CA(Certificate Authority)라고 합니다.
    참고로 서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 합니다. 인증서는 다양한 유형의 인증서가 있습니다.
    - 단일 도메인: 단 하나의 도메인(www.naver.com)에 적용되는 인증서
    - 와일드카드: 도메인의 하위 도메인도 포함하는 인증서. 예를 들어 www.cloudflare.com, blog.cloudflare.com
    - 멀티 도메인: 이름이 의미하는 것처럼 멀티 도메인 SSL 인증서는 관련되지 않은 다수의 도메인에 적용될 수 있는 인증서
- RSA의 경우 클라이언트가 생성한 임시 암호값을 서버로 전송하지만 DH의 경우 클라이언트와 서버가 서로 교환한 DH 매개변수를 사용해 개인키를 만듭니다. 
  이 때문에 RSA는 클라이언트에서 생성한 임시 암호값이 탈취당한 경우 해킹의 위험이 있습니다. 그러나 DH의 경우 탈취당해도 공통의 암호키를 못 만들기 때문에 더 좋은 것이죠.
- 0-RTT
  - 세션키가 생성된 이 후 다시 그 사이트에 방문한다면 미리 만들어 놓은 세션키(PSK, pre-shared key)를 기반으로 연결을 생성하기 때문에 
    이 때 인증에 드는 비용은 없습니다.

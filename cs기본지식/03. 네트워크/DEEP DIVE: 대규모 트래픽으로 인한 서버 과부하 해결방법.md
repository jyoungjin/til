## DEEP DIVE: 대규모 트래픽으로 인한 서버 과부하 해결방법

---

- 서버 과부하의 의미

  - 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할 때 발생합니다. 이 때 서버는 사용자의 웹요청을 처리하지 못해 응답 없음이 뜨게 됩니다.

- 모니터링을 통한 자원 할당

  - 사실 이러한 서버 과부화로 서버가 응답없음이 뜨는 것은 여러가지 이유가 있지만 그 중 하나가 바로 “자원의 한계점 도달”입니다. 
    보통 서버의 CPU 사용량이 80-90%에 도달하거나 메모리가 부족해 계속해서 스와핑이 발생하면 과부화 상태가 됩니다.
  - 이는 모니터링을 통한 자원의 적절한 할당으로 해결합니다. 자원은 CPU, 메모리, 대역폭도 포함합니다.
  - AWS 오토 스케일링
    - 서비스 이용불가능 상태 발생 이전 cloud watch가 계속해서 모니터링하여 서버 대수를 늘려주는 방법입니다.
      AWS Auto Scaling은 애플리케이션을 모니터링하고 자원의 용량을 자동으로 조정합니다.
  - netdata를 이용한 모니터링
    - 만약 AWS를 사용하지 않는다고 했을 때 무료 모니터링 서비스도 있습니다.
      이를 기반으로 지속적인 모니터링, 그리고 이를 기반으로 자원할당을 해서 해결할 수도 있습니다.
    - 참고로 이러한 모니터링 대시보드를 매번 볼 필요는 없고 slack 과 연동해서 설정한 임계치를 기반으로 알림 서비스를 구축할 수 있습니다.

- 모니터링을 왜 할까?

  - 먼저 서버과부화로 인한 조치를 하기 위해서는 1) 어떤 페이지에 어떤 트래픽이 얼마나 발생했느냐. 2) 어떤 네트워크에서 병목현상이 일어났냐. 등을 기준으로 해결할 수 있습니다.
    또한 모니터링을 하면 활용도가 낮은 페이지, 높은 페이지를 파악 할 수 있어 나중에 서비스 개선에도 도움이 됩니다.
    즉, 해결하기 위한 문제점을 파악하기 위해 모니터링은 필수적입니다.

- 로드밸런서

  - 앞서 설명한 AWS 오토스케일링은 빠르긴 하나 구성에 시간이 걸리기 때문에 앞단에 로드 밸런서를 통해 트래픽을 분산해야 합니다. 또한, 로드밸런서는 한 서버에 장애가 발생하면 로드 밸런서는 트래픽을 다른 기능 서버로 리디렉션하여 시스템 중단을 방지할 수도 있습니다.

- 블랙스완 프로토콜

  - 시스템이 다운되면 블랙스완 프로토콜을 발령하며 다음과 같은 수칙을 따릅니다.
    1. 영향을 받은 시스템과 각 시스템의 상대적 위험 수준을 확인
       체계적으로 데이터를 수집하고 원인에 대한 가설을 수립한 후 이를 테스팅
    2. 잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락
    3. 최대한 빨리 취약점에 영향을 받는 모든 시스템을 업데이트
    4. 복원계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달

- 서킷 브레이커 (실패를 포용하는 전략)

  - 서킷 브레이커는 외부 서비스의 장애로 인한 연쇄적 장애 전파를 막기 위해 자동으로 외부 서비스와 연결을 차단 및 복구하는 것을 말합니다.
    보통 MSA를 할 때 서킷 브레이커를 장착하는데요. MSA에서는 RPC나 HTTP나 gRPC를 기반으로 각각의 서비스들이 네트워크로 묶여 있습니다. 근데 여기서 네트워크 중 하나가 갑자기 오류가 생기는 상황이 발생되었을 때 다음 그림처럼 해당 네트워크 부분과 의존성이 있는 서비스까지 연쇄적으로 멈출 가능성이 있습니다. 예를 들어 다음과 같은 현상이 일어나는 것이죠.

    1. 트래픽 폭증으로 인해 API 서버 등 A 서비스의 응답이 느려진다.
    2. A 서비스의 응답이 타임아웃 시간을 초과하면 데이터를 받아오기 위해 A 서비스를 다시 호출한다.
    3. 이전에 들어온 트래픽을 다 처리하지 못한 상태에서 재시도 트래픽이 추가로 적체되어 A 서비스에 장애가 발생한다.
    4. A 서비스의 장애로 인하여 데이터를 수신하지 못해 A서비스와 의존성이 있는 다른 서비스에도 장애가 발생한다.

    보통은 2 ~ 3회정도의 재시도로 정상적인 데이터를 수신 가능하지만 장애 상황이라면 계속 재시도하는 것이 의미도 없을 뿐 아니라 외부 서비스의 장애 복구에 악영향을 미칠 수 있습니다.
    서킷브레이커를 서비스와 서비스 사이에 넣고 관련한 함수 등을 래핑해 놓습니다. 네트워크 장애를 모니터링하며 특정 서비스가 timeout으로 설정된 시간을 초과 하면 몇번의 요청을 한 이후 계속해서 timeout으로 설정된 시간을 초과하면 장애로 인식, 서킷브레이커가 trip되며 그 이후의 추가적인 호출은 발생되지 않게 합니다.(fail fast)
    다음 그림처럼 trip이 되면 서킷브레이커가 open된 상태가 됩니다. closed 상태라면 기본적인 요청을 수행하지만 open된 상태라면 오류를 기본적인 요청을 수행하지 않고 빠르게 오류를 반환하게 됩니다.
  - 서킷브레이커는 closed, open, half_open 의 상태값을 가집니다.

    - closed : 네트워크 요청의 실패율이 임계치보다 낮음. 정상
    - open : 임계치 이상의 상태. 요청을 전송하지 않고 바로 오류를 반환. fail fast
    - half_open : open 상태에서 일정 timeout으로 설정된 시간이 지나면 장애가 해결되었는지 확인하기 위해 half_open 상태로 전환됩니다. 여기서 요청을 전송하여 응답을 확인. 장애가 풀리는지를 확인해서 성공하면 closed, 실패하면 open으로 변경

- 컨텐츠 확인

  1. 불필요한 컨텐츠 제거
     - 인프런의 장애복구사례 - 불필요한 쿼리 등을 제거
       https://tech.inflab.com/202201-event-postmortem/
  2. CDN을 통한 컨텐츠 제공
     - CDN을 통해 사용자 가까이, 그리고 분산된 대규모 서버 네트워크를 기반으로 컨텐츠를 제공해서 메인 서버에 대한 부하를 줄입니다.
  3. 컨텐츠 캐싱
     - 네트워크 트래픽을 해결하는 가장 좋은 방법은 해당 트래픽이 발생하지 않도록 하는 것입니다. 
       브라우저 캐시(쿠키, 로컬저장소, 세션저장소)를 통해 해당 요청에 관한 항목을 캐시에서 응답을 읽어 네트워크 요청에 관한 비용을 모두 제거합니다.
  4. 컨텐츠 압축
     - 텍스트 기반 리소스는 gzip 또는 Brotli를 통해 압축해야 합니다. 압축하면 70% 정도까지 압축할 수 있습니다. 다만 압축했기 때문에 압축을 풀기위해 서버에서 자원(CPU)를 사용하는 양까지 고려해야 합니다. 보통은 압축하면 좋습니다.
  5. 컨텐츠의 우아한 저하 (미리 준비된 응답)
     - 시스템의 과도한 부하를 줄이기 위해 제공하는 컨텐츠 및 기능을 일시적으로 줄이는 전략입니다. 
       예를 들어 정적 텍스트 페이지를 제공하거나, 검색을 비활성화하거나 더 적은 수의 검색 결과를 반환하거나, 필수적이지 않은 기능을 비활성화 합니다.


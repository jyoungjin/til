## HTTP 상태코드 & 메서드

---

##### HTTP 상태코드

- 1xx (정보)
  - 서버가 요청을 잘 받았으며 해당 프로세스를 계속 이어가며 처리하는 것을 의미합니다. 
    - 100 : 계속함을 의미합니다.

- 2xx (성공)
  - 서버가 요청을 잘 받았고 이를 기반으로 클라이언트에게 성공적으로 데이터를 보낸 것을 의미합니다.
    - 200 OK : 요청이 성공적으로 되었습니다.
    - 201 Created : 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다.

- 3xx (리다이렉션)
  - 서버가 클라이언트의 요청에 대해 완료를 위해 추가 작업 조치가 필요합니다.
    - 301 Moved Permanently : 이 응답코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 
      변경된 새로운 URI을 301 상태코드와 함께 주어야 합니다.

- 4xx (클라이언트 오류)
  - 클라이언트가 요청한 페이지를 제공할 수 없거나 클라이언트의 요청이 잘못되어 결과적으로 요청을 처리할 수 없습니다.
    - 401 Bad Request : 서버가 클라이언트 요청을 이해할수 없음을 의미합니다.
    - 401 Unauthorized : 클라이언트의 인증이 되지 않음을 의미합니다.
    - 404 Not Found : 요청받은 컨텐츠를 찾을 수 없다는 것을 의미합니다.

- 5xx (서버 오류)
  - 서버가 클라이언트의 요청을 처리하지 못하는 상태입니다.
    - 500 Internal Server Error : 서버에 오류가 있음을 의미합니다.
    - 502 Bad Gateway : 게이트웨이 또는 프록시서버가 오류가 생겼음을 의미합니다.
    - 504 Gateway Timeout : 게이트웨이 또는 프록시서버가 정해진 Timeout 시간동안 클라이언트의 요청을 처리하지 못함을 의미합니다.


---

##### HTTP 메서드 #1. GET과 POST의 차이

- HTTP 메서드 종류
  - GET
  - POST
  - PUT
  - HEAD
  - DELETE
  - PATCH
  - OPTIONS
  - CONNECT
  - TRACE
- GET : 데이터를 읽다.
  - url을 기반으로 데이터를 요구하는 방법입니다.
  - url을 기반으로 하기 때문에 길이 제한(2000자미만)이 있습니다.
  - 성공시 HTTP 상태코드 200을 반환합니다.
  - 캐싱이 가능합니다.
  - url을 기반으로 요청하기 때문에 해당 요청의 파라미터가 브라우저기록에 남습니다.
  - url을 기반으로 요청하기 때문에 요청할 때 ASCII문자열만을 보낼 수 있습니다.
  - 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용하지 않습니다.
- POST : 데이터를 생성하다.
  - url이 아닌 HTTP message body를 통해 데이터를 전달합니다.
  - HTTP message body를 통해 전달되기 때문에 길이 제한이 없습니다.
  - 성공적으로 데이터를 생성할 경우 HTTP 상태코드 201을 반환합니다. (생성한 경우 201, 생성하지 않은 경우 200을 반환하기도 합니다.)
  - 캐싱이 불가능합니다.
  - url을 기반으로 요청하지 않기 때문에 해당 요청의 파라미터가 브라우저기록에 남지 않습니다.
  - HTTP message body로 요청하기 때문에 ASCII문자열 뿐만 아니라 모든 유형의 데이터를 기반으로 요청할 수 있습니다.
  - 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용합니다.

##### HTTP 메서드 #2. PUT과 PATCH의 차이

- PUT : 업데이트하는 데이터의 전체를 보낸다.
  - 요청을 보낼 때 해당 데이터 전체를 보내야 하고 전체 데이터의 교체를 의미합니다.
    또한, PUT은 만약 해당 데이터가 없다면 새로이 생성하고 있다면 해당 데이터가 있다면 요청할 때 보낸 데이터와 교체를 진행합니다.
    예를 들어 '{"a" : 1, "b" : 2}'가 있을 때 b를 3으로 바꾼다고 했을 때 'put'의 경우 '{"a" : 1, "b" : 3}'으로 전체 데이터 전부를 보내야 합니다.
- PATCH : 업데이트하는 데이터의 일부를 보낸다.
  - 요청을 보낼 때 수정하는 일부분만 보내면 되고 일부분의 교체를 의미합니다.
    예를 들어 '{"a" : 1, "b" : 2}'가 있을 때 b를 3으로 바꾼다고 했을 때 'patch'는 '{"b" : 3}' 이런 식으로 부분적으로 보내는 것을 말합니다.

----

##### REST API

- API (Application Programming Interface)

  - 소프트웨어와 소프트웨어 사이 데이터 전송을 가능하게 하는 프로그램

- REST API

  - 웹의 장점을 잘 살린 아키텍처이며 먼저 이 아키텍처는 Uniform-Interface를 갖는 것이 특징입니다.

  - Uniform-Interface

    - 자원들이 각각의 독립적인 인터페이스를 가져야 합니다.

      - 웹 페이지를 변경했다고 웹 브라우저를 업데이트 하는 일은 없어야 합니다.
      - HTTP 명세나 HTML 명세가 변경되어도 웹페이지는 잘 작동해야 합니다.

    - 그리고 이 아키텍처의 규칙은 다음과 같습니다.

      1. Self-descriptive messages

         - HTTP Header에 타입을 명시하고 각 메시지(자원)들은 MIME types에 맞춰 표현되어야 합니다.
           예를 들어 .json를 반환한다면 application/json으로 명시해주어야합니다.MIME types는 문서, 파일 등의 특성과 형식을 나타내는 표준입니다. 
           IETF의 RFC6838에 정의 및 표준화되어 있습니다. 'font/ttf', 'text/plain', 'text/csv' 등을 말합니다.

      2. HATEOAS 구조

         - 하이퍼링크에 따라 다른 페이지를 보여줘야 하며 데이터마다 어떤 URL에서 원했는지 명시해주어야 합니다.

         - ```javascript
           res.json(personObject, [
             { rel: "self", method: "GET", href: 'http://127.0.0.1' },
             { rel: "create", method: "POST", title: 'Create Person', href:
             'http://127.0.0.1/person' }
           ]);
           
           {"link":http://kundol.net/todos/{id}, "data":[]}
           ```

      3. Stateless

         - 이 규칙은 HTTP 자체가 Stateless이기 때문에 HTTP를 이용하는 것만으로도 만족됩니다. 즉 REST API를 제공해주는 서버는 세션(session)을 해당 서버 쪽에 유지하지 않는다는 의미입니다.

      4. Cacheable

         - HTTP는 원래 캐싱이 됩니다. 새로고침을 하면 304가 뜨면서 원래 있던 js와 css이미지 등을 불러오는 것을 볼 수 있습니다. 
           이러한 캐싱은 네트워크 요청을 줄여주며 이는 UX 향상에 도움이 됩니다. 
           네트워크 요청 시 해당되는 자원들을 복사해서 메모리에 저장해두었다가 또 같은 요청 시 네트워크 요청을 하지 않고 브라우저메모리에 있던 자원을 다시 반환합니다. 
           HTTP 메서드 중 GET에 한정되며 'Cache-Control:max-age=100‘(100초)이런 식으로 한정된 시간을 정할 수가 있으며 캐싱된 데이터가 유효한지를 판단하기 위해 'Last-modifed'와 'Etag'를 씁니다.'Etag'는 전달되는 값에 태그를 붙여서 캐싱되는 자원인지를 확인해주는 것입니다.

      5. Client-Server 구조

         - 클라이언트와 서버가 서로 독립적인 구조를 가져야 합니다. 물론 이는 HTTP를 통해 가능한 구조입니다. 
           서버에서 HTTP 표준만 지킨다면 웹에서는 그에 따른 화면이 잘 나타나게 됩니다. 
           서버는 그저 API를 제공하고 그 API에 맞는 비즈니스 로직을 처리하면 됩니다. 마찬가지로 클라이언트에서는 HTTP로 받는 로직만 잘 처리하면 되는 것입니다.

      6. Layered System

         - 계층구조로 아키텍처를 만들 수 있다는 것을 뜻합니다.

    - URI 규칙

      1. 동작은 HTTP 메소드로 해야 합니다. 수정 = put, 삭제 = delete, 추가 = post,조회 = get을 이용해야 합니다. 예를 들어 '/books/delete/1' 이렇게 표기하면 안 된다는 것입니다. 
      2. 확장자는 표기하지 말아야 합니다.
      3. 동사가 아닌 명사로만 표기해야 합니다. **유저가 책을 소유한다**라고 하려면 이런 식으로 구성되어야 합니다. '유저/유저아이디/inclusion/책/책아이디'
      4. URI는 계층적인 내용을 담고 있습니다. '/집/아파트/전세' 이런 식으로 내려가야 합니다. 
      5. 소문자로 쓰며 너무 길 경우에는 **-**를 씁니다.
      6. HTTP 응답 상태코드를 활용합니다.
